Function List
AIInterface
Functions

void  AI_ClearCaptureImportanceBonus( ModPlayer* pPlayer, Entity* pEntity )
 	
This clears the importance bonus on this capture point 

 
void  AI_ClearImportance( ModPlayer* pPlayer, Entity* pEntity )
 	
This clears the importance override on this military point 

 
AIObjective*  AI_CreateObjective( ModPlayer* pPlayer, uint32_t objectiveType )
 	
Create a new objective for player 

 
void  AI_DebugAttackEncounterPositionScoringEnable( bool enable )
 	
Enables/disables debugging of AI Attack Objective Encounter Position Scoring 

 
bool  AI_DebugAttackEncounterPositionScoringIsEnabled( Void  )
 	
Returns true if AI Attack Objective Encounter Position Scoring is enabled 

 
void  AI_DebugLuaEnable( bool enable )
 	
Enables/disables AI Lua Debugging 

 
bool  AI_DebugLuaIsEnabled( Void  )
 	
Returns true if AI Lua Debugging is enabled 

 
void  AI_DebugRatingEnable( bool enable )
 	
Enables/disables AI Construction Debugging 

 
bool  AI_DebugRatingIsEnabled( Void  )
 	
Returns true if AI Construction Debugging is enabled 

 
void  AI_DebugRenderAllTaskChildrenEnable( bool enable )
 	
Enables/disables AI Rendering of All Task Children 

 
bool  AI_DebugRenderAllTaskChildrenIsEnabled( Void  )
 	
Returns true if AI Rendering of All Task Children is enabled 

 
void  AI_DebugSkirmishCaptureEnable( bool enable )
 	
Enables/disables AI Skirmish Capture Debugging 

 
bool  AI_DebugSkirmishCaptureIsEnabled( Void  )
 	
Returns true if AI Skirmish Capture Debugging is enabled 

 
void  AI_DebugSkirmishCombatTargetEnable( bool enable )
 	
Enables/disables AI Skirmish Combat Target Debugging 

 
bool  AI_DebugSkirmishCombatTargetIsEnabled( Void  )
 	
Returns true if AI Skirmish Combat Target Debugging is enabled 

 
void  AI_DebugSkirmishObjectiveEnable( bool enable )
 	
Enables/disables AI Skirmish Objective Debugging 

 
bool  AI_DebugSkirmishObjectiveIsEnabled( Void  )
 	
Returns true if AI Skirmish Objective Debugging is enabled 

 
void  AI_DisableAllEconomyOverrides( ModPlayer* pPlayer )
 	
Disable all of the economy overrides for the AI player 

 
void  AI_Enable( ModPlayer* pPlayer, bool enable )
 	
Enables or Disables an AI player 

 
void  AI_EnableAll( bool enable )
 	
Enables or Disables all AI players 

 
void  AI_EnableEconomyOverride( ModPlayer* pPlayer, const char* overrideName, bool enable )
 	
Enable or disable the economy override for the AI player 

 
int  AI_GetDifficulty( ModPlayer* pPlayer )
 	
Gets the difficulty level of this AI player 

Levels can be one of: AD_Easy, AD_Standard, AD_Hard, AD_Hardest

 
const char*  AI_GetPersonality( ModPlayer* pPlayer )
 	
Get the personality name of this AI player 

 
const char*  AI_GetPersonalityLuaFileName( ModPlayer* pPlayer )
 	
Get the personality lua file name of this AI player 

 
bool  AI_IsAIPlayer( ModPlayer* pPlayer )
 	
Returns true if player is an AI player 

 
bool  AI_IsEnabled( ModPlayer* pPlayer )
 	
Returns true if player is a AIPlayer and is enabled 

 
void  AI_LockEntity( ModPlayer* pPlayer, Entity* pEntity )
 	
Locks the entity and disables its tactics (if any) and the AI will no longer use this object 

 
void  AI_LockSquad( ModPlayer* pPlayer, Squad* pSquad )
 	
Locks the squad and disables its tactics (if any) and the AI will no longer use this object 

 
void  AI_LockSquads( ModPlayer* pPlayer, SGroup* squads )
 	
Locks the squads and disables its tactics (if any) and the AI will no longer use these objects 

 
void  AI_RestoreDefaultPersonalitySettings( ModPlayer* pPlayer )
 	
Restores the default personality and difficulty settings of this AI player 

 
void  AI_SetCaptureImportanceBonus( ModPlayer* pPlayer, Entity* pEntity, float importanceBonus )
 	
This sets importance bonus of the given capture point 

 
void  AI_SetDifficulty( ModPlayer* pPlayer, int difficultyLevel )
 	
Set the difficulty level of this AI player 

Levels can be one of: AD_Easy, AD_Standard, AD_Hard, AD_Hardest

 
void  AI_SetImportance( ModPlayer* pPlayer, Entity* pEntity, float importance )
 	
This overrides the default importance of the given military point 

 
void  AI_SetPersonality( ModPlayer* pPlayer, const char* personalityName )
 	
Set the personality name of this AI player 

 
void  AI_UnlockAll( ModPlayer* pPlayer )
 	
Unlocks all designer locked squads for player 

 
void  AI_UnlockEntity( ModPlayer* pPlayer, Entity* pEntity )
 	
Unlocks this entity so that AI can use it again 

 
void  AI_UnlockSquad( ModPlayer* pPlayer, Squad* pSquad )
 	
Unlocks the given squad so the AI can use it again 

 
void  AI_UnlockSquads( ModPlayer* pPlayer, SGroup* squads )
 	
Locks the squads and disables its tactics (if any) and the AI will no longer use these objects 

 
void  AI_UpdateStatics( ModPlayer* pPlayer )
 	
Re-updates the AI in regards to all the static objects in the world (if SCAR creates new strategic points dynamically this will need to be called) 

 
void  AIAbilityObjective_AbilityGuidance_SetAbilityPBG( AIObjective* pObjective, const PropertyBagGroup* abilityPBG )
 	
Set ability for ability objective 

 
void  AIObjective_Cancel( AIObjective* pObjective )
 	
Ends the objective and deletes it. 

 
void  AIObjective_CombatGuidance_EnableCombatGarrison( AIObjective* pObjective, bool enable )
 	
Enables/disables squads in combat garrisoning. 

 
void  AIObjective_CombatGuidance_EnableRetaliateAttacks( AIObjective* pObjective, bool enable )
 	
Enables/disables allowing squads to retaliate against attacking enemies outside the allowed leash area 

 
void  AIObjective_CombatGuidance_SetRetaliateAttackTargetAreaRadius( AIObjective* pObjective, float radius )
 	
Sets the target area radius for the maximum range an enemy can be for a retaliate attack 

 
void  AIObjective_DefenseGuidance_AddFacingPosition( AIObjective* pObjective, ScarPosition pos )
 	
Add facing position to objective; used to determine good defensive setup positions. 

 
void  AIObjective_DefenseGuidance_EnableIdleGarrison( AIObjective* pObjective, bool enable )
 	
Enables/disables idle squads garrisoning. 

 
void  AIObjective_DefenseGuidance_ResetFacingPositions( AIObjective* pObjective )
 	
Remove all facing positions from objective. 

 
void  AIObjective_EngagementGuidance_EnableAggressiveEngagementMove( AIObjective* pObjective, bool enable )
 	
Enable / disable aggressive move into engagement area 

 
void  AIObjective_EngagementGuidance_SetAllowReturnToPreviousStages( AIObjective* pObjective, bool enable )
 	
Enable objective to return to previous stages if they fail to meet conditions for current stage. 

 
void  AIObjective_EngagementGuidance_SetCoordinatedSetup( AIObjective* pObjective, bool enable )
 	
Enable coordinated arrival or setup of squads at engagement area. 

 
void  AIObjective_EngagementGuidance_SetMaxEngagementTime( AIObjective* pObjective, float seconds )
 	
Sets max time, in seconds, to accomplish objective, once the target is engaged. 

 
void  AIObjective_EngagementGuidance_SetMaxIdleTime( AIObjective* pObjective, float seconds )
 	
Sets max time, in seconds, to remain idle at objective target, once engaged. 

 
void  AIObjective_FallbackGuidance_EnableRetreatOnPinned( AIObjective* pObjective, bool enable )
 	
Enable retreat to break supression. 

 
void  AIObjective_FallbackGuidance_EnableRetreatOnSuppression( AIObjective* pObjective, bool enable )
 	
Enable retreat to break supression. 

 
void  AIObjective_FallbackGuidance_SetEntitiesRemainingThreshold( AIObjective* pObjective, float value )
 	
Set entities remaining threshold of encounter [0-N] to fallback at. 

 
void  AIObjective_FallbackGuidance_SetFallbackCapacityPercentage( AIObjective* pObjective, float value )
 	
Set health threshold [0-1] to fallback at. 

 
void  AIObjective_FallbackGuidance_SetFallbackCombatRatingPercentage( AIObjective* pObjective, float value )
 	
Set health threshold [0-1] to fallback at. 

 
void  AIObjective_FallbackGuidance_SetFallbackSquadHealthPercentage( AIObjective* pObjective, float value )
 	
Set combat rating threshold of area [0-1] to fallback at. 

 
void  AIObjective_FallbackGuidance_SetFallbackVehicleHealthPercentage( AIObjective* pObjective, float value )
 	
Set health threshold [0-1] to fallback at. 

 
void  AIObjective_FallbackGuidance_SetGlobalFallbackPercentage( AIObjective* pObjective, float value )
 	
Set global fallback threshold (0.0f for individual squad). 

 
void  AIObjective_FallbackGuidance_SetGlobalFallbackRetreat( AIObjective* pObjective, bool value )
 	
Set global retreat type (true for retreat; false for fallback). 

 
void  AIObjective_FallbackGuidance_SetRetreatCapacityPercentage( AIObjective* pObjective, float value )
 	
Set combat rating threshold of area [0-1] to fallback at. 

 
void  AIObjective_FallbackGuidance_SetRetreatCombatRatingPercentage( AIObjective* pObjective, float value )
 	
Set combat rating threshold of area [0-1] to fallback at. 

 
void  AIObjective_FallbackGuidance_SetRetreatHealthPercentage( AIObjective* pObjective, float value )
 	
Set combat rating threshold of area [0-1] to fallback at. 

 
void  AIObjective_FallbackGuidance_SetTargetPosition( AIObjective* pObjective, ScarPosition pos )
 	
Set fallback target. 

 
bool  AIObjective_IsValid( AIObjective* pObjective )
 	
Determines if objective is still valid. Must be true before calling any other of the AIObjective_* function. Return true if valid, false otherwise. 

 
void  AIObjective_MoveGuidance_EnableAggressiveMove( AIObjective* pObjective, bool enable )
 	
Enable / disable aggressive movements on way to engagement targets 

 
void  AIObjective_MoveGuidance_ResetPathingLengthFactor( AIObjective* pObjective )
 	
Reset preference for shorter paths on way to engagement targets, to defaults 

 
void  AIObjective_MoveGuidance_ResetSafePathingWeight( AIObjective* pObjective )
 	
Reset preference for safe movements on way to engagement targets, to defaults 

 
void  AIObjective_MoveGuidance_SetPathingLengthFactor( AIObjective* pObjective, float weight )
 	
Set preference for shorter paths on way to engagement targets 

 
void  AIObjective_MoveGuidance_SetSafePathingWeight( AIObjective* pObjective, float weight )
 	
Set preference for safe movements on way to engagement targets 

 
void  AIObjective_MoveGuidance_SetSquadCoherenceRadius( AIObjective* pObjective, float radius )
 	
Set radius (follow distance) for coordinated move phase (<= 0 disables coordinated movement) 

 
void  AIObjective_Notify_ClearCallbacks( AIObjective* pObjective )
 	
Clears all notification callbacks for objective 

 
void  AIObjective_Notify_SetPlayerEventObjectiveID( AIObjective* pObjective, uint32_t id )
 	
Sets the ID for the notification event sent out by objective 

 
void  AIObjective_ResourceGuidance_ClearSquads( AIObjective* pObjective )
 	
Removes all resource squads from objective. 

 
void  AIObjective_ResourceGuidance_SquadGroup( AIObjective* pObjective, SGroup* squads )
 	
Sets the resource squads for objective. 

 
void  AIObjective_SetName( AIObjective* pObjective, const char* name )
 	
Set objective name for debugging. 

 
void  AIObjective_TacticFilter_DisableAbility( AIObjective* pObjective, const PropertyBagGroup* ability )
 	
Disable ability for all squads in objective 

 
void  AIObjective_TacticFilter_DisableAbilityForSquadGroup( AIObjective* pObjective, SGroup* squads, const PropertyBagGroup* ability )
 	
Disable ability for squads in objective 

 
void  AIObjective_TacticFilter_EnableCloseGround( AIObjective* pObjective, float priority )
 	
Enable close ground behaviour (3-stage TACTIC_RushAtTarget) for all squads in objective, running at priority (1..1000) 

 
void  AIObjective_TacticFilter_Reset( AIObjective* pObjective )
 	
Reset all tactic filters for objective 

 
void  AIObjective_TacticFilter_ResetAbilityGuidance( AIObjective* pObjective )
 	
Reset all tactic ability constraints for objective 

 
void  AIObjective_TacticFilter_ResetPriority( AIObjective* pObjective, AITacticType tactic )
 	
Reset tactic priority for all squads in objective 

 
void  AIObjective_TacticFilter_ResetTacticGuidance( AIObjective* pObjective )
 	
Reset all tactic constraints for objective 

 
void  AIObjective_TacticFilter_ResetTargetGuidance( AIObjective* pObjective )
 	
Reset all tactic target constraints for objective 

 
void  AIObjective_TacticFilter_SetAbilityGuidance( AIObjective* pObjective, const PropertyBagGroup* ability, int32_t maxCasters, float retrySecs, float waitSecs, float timeoutSecs, bool initialWait, float maxRange )
 	
Set tactic ability constraints for objective 

 
void  AIObjective_TacticFilter_SetDefaultAbilityGuidance( AIObjective* pObjective, int32_t maxCasters, float retrySecs, float waitSecs, float timeoutSecs, bool initialWait, float maxRange )
 	
Set default tactic ability constraints for objective (ability specific guidance takes priority over defaults) 

 
void  AIObjective_TacticFilter_SetDefaultTacticGuidance( AIObjective* pObjective, int32_t maxUsers, float retrySecs, float waitSecs, float timeoutSecs, bool initialWait, float maxRange )
 	
Set default tactic constraints for objective (tactic specific guidance takes priority over defaults) 

 
void  AIObjective_TacticFilter_SetDefaultTargetGuidance( AIObjective* pObjective, int32_t maxAttackers )
 	
Set default target constraints for objective (target specific guidance takes priority over defaults) 

 
void  AIObjective_TacticFilter_SetPriority( AIObjective* pObjective, AITacticType tactic, float priority )
 	
Set tactic priority for all squads in objective; negative priority disables 

 
void  AIObjective_TacticFilter_SetPriorityForSquadGroup( AIObjective* pObjective, SGroup* squads, AITacticType tactic, float priority )
 	
Set tactic priority for squads in objective 

 
void  AIObjective_TacticFilter_SetTacticGuidance( AIObjective* pObjective, AITacticType tactic, int32_t maxUsers, float retrySecs, float waitSecs, float timeoutSecs, bool initialWait, float maxRange )
 	
Set tactic constraints for objective 

 
void  AIObjective_TacticFilter_SetTargetPolicy( AIObjective* pObjective, TargetPreference policy )
 	
Set tactic target priority for objective 

 
void  AIObjective_TargetGuidance_SetTargetArea( AIObjective* pObjective, float radius )
 	
Sets engagement area radius around the target.  

 
void  AIObjective_TargetGuidance_SetTargetEntity( AIObjective* pObjective, Entity* entity )
 	
Sets target Entity for objective 

 
void  AIObjective_TargetGuidance_SetTargetLeash( AIObjective* pObjective, float radius )
 	
Sets leash radius around target where squads should stay within.  

 
void  AIObjective_TargetGuidance_SetTargetPathByName( AIObjective* pObjective, const char* pathName, float delaySecs )
 	
Sets target patrol path for objective 

 
void  AIObjective_TargetGuidance_SetTargetPathWander( AIObjective* pObjective, float delaySecs )
 	
Sets random wander target patrol for objective; delaySecs is the time in secs to pause at each random point 

 
void  AIObjective_TargetGuidance_SetTargetPosition( AIObjective* pObjective, ScarPosition pos )
 	
Sets target position for objective 

 
void  AIObjective_TargetGuidance_SetTargetSquad( AIObjective* pObjective, Squad* squad )
 	
Sets target Squad for objective 

 
 

 

BeginnerHint
Functions

OpportunityID  BeginnerHint_AddOpportunity( Pos/Group/Table where, AbilityID/Table ability[, Bool repeating, LocText message, String icon, HPAT arrow, GD max_difficulty, Bool ignore_timers] )
 	
Add an opportunity that may get highlighted by the hint manager system on easier difficulty modes. THIS IS NOT MP-SAFE! 

 
Void  BeginnerHint_RemoveAllOpportunities( )
 	
Remove all opportunities in one fell swoop! 

 
Void  BeginnerHint_RemoveOpportunity( Pos/OpportunityID where )
 	
Remove an opportunity, either by ID or all opportunities at a location 

 
 

 

Blueprint
Functions

ScarAbilityPBG  BP_GetAbilityBlueprint( const char* pbgShortname )
 	
Returns an ability property bag group. 

 
ScarCamouflageStancePBG  BP_GetCamouflageStanceBlueprint( const char* pbgShortname )
 	
Returns a camouflage stance property bag group. 

 
ScarCriticalPBG  BP_GetCriticalBlueprint( const char* pbgShortname )
 	
Returns a critical property bag group. 

 
ScarEntityPBG  BP_GetEntityBlueprint( const char* pbgShortname )
 	
Returns an entity property bag group. 

 
uint32_t  BP_GetID( const PropertyBagGroup* pbg )
 	
Returns an ID that uniquely identifies this pbg 

 
ScarMoveTypePBG  BP_GetMoveTypeBlueprint( const char* pbgShortname )
 	
Returns a move type property bag group. 

 
const char*  BP_GetName( const PropertyBagGroup* pbg )
 	
Return the short name of the group 

Example name would be "ally_mad_minute_ability"

 
int  BP_GetPropertyBagGroupCount( LuaBinding::StackVar type )
 	
Return the number of property bag groups of the same type 

Example type would be PBG_Critical

 
const char*  BP_GetPropertyBagGroupPathName( LuaBinding::StackVar type, size_t index )
 	
Return the path name of the group at the specified index 

Example name would be "abilities\ally_mad_minute_ability"

 
ScarSlotItemPBG  BP_GetSlotItemBlueprint( const char* pbgShortname )
 	
Returns a slot item property bag group. 

 
ScarSquadPBG  BP_GetSquadBlueprint( const char* pbgShortname )
 	
Returns a squad property bag group. 

 
ScarUpgradePBG  BP_GetUpgradeBlueprint( const char* pbgShortname )
 	
Returns an upgrade property bag group. 

 
ScarWeaponPBG  BP_GetWeaponBlueprint( const char* pbgShortname )
 	
Returns a weapon property bag group. 

 
bool  EBP_Exists( const char* pbgShortname )
 	
Returns true if an entity blueprint exists with the given name. 

 
bool  SBP_Exists( const char* pbgShortname )
 	
Returns true if a squad blueprint exists with the given name. 

 
 

 

Camera
Functions

Void  Camera_CyclePositions( Table list[, Boolean pan, Float panRate, ScarFn callback] )
 	
Moves the camera through a list of positions. 

 
Void  Camera_Follow( Variable var )
 	
Set the camera to follow an sgroup/squad/egroup/entity. 

The camera will follow them until the player takes control again.

 
Void  Camera_MoveTo( Variable var[, Boolean pan, Float panRate, Boolean keepInputLocked, Boolean resetToDefault] )
 	
Move the camera to an entity/marker/pos/egroup/sgroup/squad 

This function canNOT be called through a CTRL object in NISlets.

 
Void  Camera_MoveToIfClose( Variable var )
 	
Slightly refocus the camera to rest on an entity/squad/squad/sgroup/egroup/pos/marker if it's close by. 

This function can be called through a CTRL object in NISlets.

 
Void  Camera_SetDefault( Float height, Float declination, Float angle )
 	
Helper function to set the default camera parameters 

If the parameter is nil, the particular property is not modified

 
 

 

Command
Functions

Void  Cmd_AbandonTeamWeapon( SGroupID sgroupid[, Boolean preserveCrew, Boolean queued] )
 	
Order a squad group to abandon their current team weapon if they have it and they could (tuning value in attribute editor) 

 
Void  Cmd_Ability( PlayerID/EGroupID/SGroupID user, AbilityBlueprint blueprint, [Position/SGroupID/EGroupID target, Position direction, Bool skipCostPrereq, Bool queued] )
 	
Sends an ability command to a player, egroup or sgroup. extra parameters are provided if the ability requires them. 

 
Void  Cmd_AttachSquads( SGroupID sgroup, SGroupID sgroupAttachee )
 	
Attach the squad from sgroupnameAttachee to sgroupname. Both SGroups must contain only one squad. 

 
Void  Cmd_Attack( SGroupID sgroup, SGroup/EGroup/Pos/Marker target[, Boolean queued, Boolean stationary, String plan] )
 	
Issues an attack command to an SGroup 

 
Void  Cmd_AttackMove( SGroupID sgroup, Position targetposition[, Boolean queued, String plan, Real coverSearchRadius, MarkerID deleteWhenNearMarker] )
 	
Order a squad group to attack move to a position (anything whose position can be queried). can be queued, can follow a plan, can search for cover within a radius 

 
Void  Cmd_AttackMoveThenCapture( SGroupID attacker, EGroupID target, [!Boolean!queued ] )
 	
Command attacker sgroup to attack move to strategic point target; when it is capturable, the sgroup would capture it 

 
Void  Cmd_CaptureTeamWeapon( SGroupID sgroupid, EGroupID targetid, [Boolean queued] )
 	
Order a squad group to capture team weapon entity group. 

 
Void  Cmd_Construct( SGroup sgroupid, Entity blueprint, EGroupID/Position/Marker targetid[, Position Facing, Boolean queued] )
 	
Orders a squad to contruct a building at specified position, or to continue construction on an existing building. 

The command also checks to see if a building already exists at the location, and the squad will continue building it, if it is of the correct type.

 
Void  Cmd_CriticalHit( PlayerID playerid, SGroupID/EGroupID/Squad/Entity target, CriticalID criticalid, Real removeAtHealth )
 	
Applies critical hit to entity/squad/sgroup/egroup 

Player id doesn't have to be the owner as the applied entities but need to make sure the player is still alive

 
Void  Cmd_DetonateDemolitions( PlayerID player, EGroupID target[, Boolean queued] )
 	
Detonates a building's demolitions 

 
Void  Cmd_EjectOccupants( EGroupID/SGroupID fromgroupid[, Position destination, Boolean queued] )
 	
Orders an EGroup or SGroup to kick out its occupants. If no position is specified, the occupants stay at the exit. 

 
EntityID or SquadID id of the destination  Cmd_Garrison( SGroupID fromsgroupid, EGroupID/SGroupID togroupid, [Bool overload, Bool queued, Bool instant] )
 	
Order a squad group to load at a random entity or squad of the group 

overload is a flag that will allow the hold entity to ignore maximum slot check

 
Void  Cmd_InstantReinforceUnit( SGroupID sgroup, Integer count )
 	
Sends a instant reinforce command to all squads in a group. count represents the number of commands to send. 

Note: This function bypasses pre-reqs, costs and the production queue

 
Void  Cmd_InstantReinforceUnitPos( SGroupID sgroup, Integer count, MarkerID/Pos spawnlocation[, Integer checktype[, Integer failtype]] )
 	
Sends a instant reinforce command to all squads in a group. count represents the number of commands to send. spawnlocation is where the reinforced unit will spawn. You can optionally find a hidden position by specifying a checktype (CHECK_OFFCAMERA, CHECK_IN_FOW or CHECK_BOTH), and what to do if a hidden position can't be found (SPAWN_ATMARKER, SPAWN_ATSQUAD, or DO_NOTHING) - SPAWN_ATMARKER is the default. 

Note: This function bypasses pre-reqs and costs and the production queue

 
Void  Cmd_InstantSetupTeamWeapon( SGroupID sgroupid, [Boolean queued] )
 	
Order a squad group to instant setup their team weapon 

 
Void  Cmd_InstantUpgrade( PlayerID/EGroupID/SGroupID target, UpgradeBlueprint/Table blueprint[, Integer count] )
 	
Sends an instant upgrade command to a player, egroup or sgroup. accepts a single upgrade or table of upgrades. 

 
Void  Cmd_Move( SGroupID sgroup, Pos/SGroupID/EGroupID/MarkerID position, [Boolean queued, MarkerID deleteWhenNearMarker, Position facing, Integer offset, Real distance, Real coverSearchRadius] )
 	
Move a squad group to a given position. 

Supports facing, 'offset' movement, and can find cover. The sgroup can be deleted when in proximity of a marker (it assumes a proximity of 5 if you forget to set one on the marker)

 
Void  Cmd_MoveAwayFromPos( SGroupID sgroup, Pos position, Int radius, [Boolean queued] )
 	
Move a squad group out of a position to a certain radius 

All squads in the group will move away from the centre position from its current position

 
Void  Cmd_MoveToAndDespawn( SGroupID sgroup, MarkerID marker, boolean queued )
 	
Moves a squad group to the indicated Marker and destroys it. 

 
markerID  Cmd_MoveToClosestMarker( SGroupID sgroup, Table markertable )
 	
Moves a squad group to the closest marker in a list/table of MarkerIDs. 

 
Void  Cmd_MoveToThenCapture( SGroupID attacker, EGroupID target, [!Boolean!queued ] )
 	
Command attacker sgroup to attack move to strategic point target; when it is capturable, the sgroup would capture it 

 
Void  Cmd_RecrewVehicle( SGroupID sgroupid, EGroupID targetid, [Boolean queued] )
 	
Order a squad group to recrew an abandoned vehicle. 

 
Void  Cmd_ReinforceUnit( SGroupID sgroup, Integer count )
 	
Sends a reinforce command to all squads in a group. count represents the number of commands to send. 

Note: To reinforce squad bypassing the pre-reqs and costs use Cmd_InstantReinforceUnit.

 
Void  Cmd_ReinforceUnitPos( SGroupID sgroup, Integer count, MarkerID/Pos spawnlocation[, Integer checktype[, Integer failtype]] )
 	
Sends a reinforce command to all squads in a group. count represents the number of commands to send. spawnlocation is where the reinforced unit will spawn. You can optionally find a hidden position by specifying a checktype (CHECK_OFFCAMERA, CHECK_IN_FOW or CHECK_BOTH), and what to do if a hidden position can't be found (SPAWN_ATMARKER, SPAWN_ATSQUAD, or DO_NOTHING) - SPAWN_ATMARKER is the default. 

To reinforce squads bypassing the pre-reqs and costs use Cmd_InstantReinforceUnit

 
Void  Cmd_Retreat( SGroupID sgroup[, Position location, MarkerID deleteWhenNearMarker, Boolean queued, Boolean saveEncountersk, Boolean vulnerableRetreat] )
 	
Order a squad group to retreat, optionally to a specific location. The sgroup can be deleted when in proximity of a marker (it assumes a proximity of 5 if you forget to set one on the marker) 

vulnerableRetreat will make retreating squads take more damage

 
Void  Cmd_RevertOccupiedBuilding( SGroupID sgroupid, EGroupID targetid, [Boolean queued] )
 	
Order a squad group to revert occupied building 

 
Void  Cmd_SetDemolitions( SGroupID sgroupid, EGroupID targetid[, Boolean skipCostPrereq, Boolean queued] )
 	
Orders a squad group to place demolition charges on a building (egroup). Function does nothing if egroup cannot be detonated, or player can't afford the demolitions 

 
Void  Cmd_SquadCamouflageStance( SGroupID sgroup, CamouflageStanceID stanceid )
 	
Sends an camouflage stance command to all squads in a group. stanceid should be the number returned by Util_GetCamouflageStanceID( stancename ) 

 
Void  Cmd_SquadPath( SGroupID sgroup, String pathName, Boolean bFromClosest, Integer loop, Boolean bAttackMove, Float pauseTime[, MarkerID deleteWhenNearMarker, Boolean queued, Boolean bMoveForward] )
 	
Send a command to the squad to follow a path. Can wait at each waypoint. The sgroup can be deleted when in proximity of a marker if you pass in the marker as the 7th argument (it assumes a proximity of 5 if you forget to set one on the marker) 

loop can be: LOOP_NONE, LOOP_NORMAL, LOOP_TOGGLE_DIRECTION

 
Void  Cmd_SquadPatrolMarker( SGroupID sgroup, MarkerID marker )
 	
Causes a squad to patrol a marker attacking any enemies that come within its radius. If used on circular markers, the radius must be at least 5. To stop the squad from patrolling the marker, use Cmd_Stop. 

 
Void  Cmd_StaggeredRetreat( SGroupID sgroup, Table markers, [Integer maxTries, Boolean vulnerableRetreat] )
 	
Retreats large numbers of units in a staggered, realistic manner. 

vulnerableRetreat will make retreating squads take more damage

 
Void  Cmd_Stop( EGroupID/SGroupID group )
 	
Sends a stop command to egroup or sgroup. 

 
Void  Cmd_Surrender( SGroup!sgroupid [, Integer actionpoints, Position exitpos, Boolean deleteAtExit, Boolean removeWeapon] )
 	
Orders a squad to surrender and awards the local player with an appropriate number of action points 

The command will also overwrite the exit position as well, if you do not want the squads to exit at the map entry point.

 
Void  Cmd_UngarrisonSquad( SGroupID sgroupid[, Position destination, Boolean queued] )
 	
Orders an sgroup to exit the building or vehicle that it's in. If no position is specified, the sgroup stays at the exit. 

 
Void  Cmd_Upgrade( PlayerID/EGroupID/SGroupID user, UpgradeBlueprint/Table blueprint[, Integer count, Boolean instant] )
 	
Sends an upgrade command to a player, egroup or sgroup. accepts a single upgrade or table of upgrades. 

 
void  Command_Entity( Player* player, EGroup* egroup, EntityCommandType entityCommand )
 	
Send a entity command to a entity group(CMD_DefaultAction, CMD_Stop, CMD_Destroy, CMD_BuildSquad, CMD_CancelProduction, CMD_RallyPoint, CMD_AttackForced) 

Entity commands are mostly used for buildings etc. If you need to issue commands to units, use the Squad_Command function.

 
void  Command_EntityAbility( Player* player, EGroup* egroup, ScarAbilityPBG abilityPBG, bool skipCostPrereq, bool queued )
 	
Send an entity ability command (CMD_Ability) to an entity 

 
void  Command_EntityBuildSquad( Player* player, EGroup* egroup, ScarSquadPBG squadPbg )
 	
Send a squad command to a entity group with custom data 

 
void  Command_EntityEntity( Player* player, EGroup* egroup, EntityCommandType entityCommand, EGroup* target )
 	
Send a entity-based command to an entity group. 

Use this function to issue orders that require a entity to an entity group (eg. order a building to attack another building)<BR/> See Command_Entity for a list of all the possible entityCommands.

 
void  Command_EntityExt( Player* player, EGroup* egroup, EntityCommandType entityCommand, uint32_t cmdparam, bool queued )
 	
Send a squad command to a squad group with custom data 

 
void  Command_EntityPos( Player* player, EGroup* egroup, EntityCommandType entityCommand, ScarPosition target )
 	
Send a position command to an entity group. 

Use this function to issue orders that require a position to an entity group (eg. set a rally point for a building)<BR/> See Command_Entity for a list of all the possible entityCommands.

 
void  Command_EntityPosAbility( Player* player, EGroup* egroup, ScarPosition pos, ScarAbilityPBG abilityPBG, bool skipCostPrereq, bool queued )
 	
Send a positional ability command (CMD_Ability) to an entity 

Use this function to issue ability orders that require a position to player

 
void  Command_EntityPosDirAbility( Player* player, EGroup* egroup, ScarPosition pos, ScarPosition dir, ScarAbilityPBG abilityPBG, bool skipCostPrereq, bool queued )
 	
Send a positional/directional ability command (CMD_Ability) to an entity 

Use this function to issue ability orders that require a position and a direction to player

 
void  Command_EntityPosSquad( Player* player, EGroup* egroup, EntityCommandType entityCommand, ScarPosition target, SGroup* sgroup )
 	
Send a dual target (position and squad) command to an entity group. 

Use this function to issue orders that require a position and a squad to an entity group (eg. unloading squad from hold)<BR/> See Command_Entity for a list of all the possible entityCommands.

 
void  Command_EntitySquad( Player* player, EGroup* egroup, EntityCommandType entityCommand, SGroup* target )
 	
Send a squad-based command to an entity group. 

Use this function to issue orders that require a squad to an entity group (eg. order a building to attack a squad)<BR/> See Command_Entity for a list of all the possible entityCommands.

 
void  Command_EntityTargetEntityAbility( Player* player, EGroup* egroup, Entity* entityTarget, ScarAbilityPBG abilityPBG, bool skipCostPrereq, bool queued )
 	
Send an entity-targeting ability command (CMD_Ability) to an entity 

Use this function to issue ability orders that require an entity target to an entity

 
void  Command_EntityTargetSquadAbility( Player* player, EGroup* egroup, Squad* squadTarget, ScarAbilityPBG abilityPBG, bool skipCostPrereq, bool queued )
 	
Send an squad-targeting ability command (CMD_Ability) to an entity 

Use this function to issue ability orders that require an entity target to an entity

 
void  Command_EntityUpgrade( Player* player, EGroup* egroup, ScarUpgradePBG upgrade, bool instant, bool queued )
 	
Send a squad command to a entity group with custom data 

 
void  Command_Player( Player* player, Player* dest, PlayerCommandType playerCommand )
 	
Send a player command to a player 

PCMD_Ability

 
void  Command_PlayerAbility( Player* player, Player* dest, ScarAbilityPBG abilityPBG, bool skipCostPrereq )
 	
Send a player ability command (PCMD_Ability) to a player 

 
void  Command_PlayerEntity( Player* player, Player* dest, PlayerCommandType playerCommand, EGroup* target )
 	
Send an entity command to a player. 

 
void  Command_PlayerEntityCriticalHit( Player* player, EGroup* egroup, PlayerCommandType playerCommand, ScarCriticalPBG criticalPBG, float removeAtHealth, bool queued )
 	
Send a player command to itself to act upon single with custom parameter and index data (PCMD_CriticalHit) 

This is a special command for SCAR and debug feature

 
void  Command_PlayerExt( Player* player, Player* dest, PlayerCommandType playerCommand, uint32_t cmdparam, bool queued )
 	
Send a player command to a player with a custom flag 

 
void  Command_PlayerPos( Player* player, Player* dest, PlayerCommandType playerCommand, ScarPosition pos )
 	
Send a position command to a player. 

Use this function to issue orders that require a position to player)<BR/> See Command_Player for a list of all the possible playerCommands.

 
void  Command_PlayerPosAbility( Player* player, Player* dest, ScarPosition pos, ScarAbilityPBG abilityPBG, bool skipCostPrereq )
 	
Send a positional ability command (PCMD_Ability) to a player 

Use this function to issue ability orders that require a position to player

 
void  Command_PlayerPosDirAbility( Player* player, Player* dest, ScarPosition pos, ScarPosition dir, ScarAbilityPBG abilityPBG, bool skipCostPrereq )
 	
Send a positional/directional ability command (PCMD_Ability) to a player 

Use this function to issue ability orders that require a position and a direction to player

 
void  Command_PlayerPosExt( Player* player, Player* dest, PlayerCommandType playerCommand, ScarPosition pos, uint32_t cmdparam, bool queued )
 	
Send a position command to a player with extra info 

Use this function to issue orders that require a position to player<BR/> See Command_Player for a list of all the possible playerCommands.

 
void  Command_PlayerSquadConstructBuilding( Player* player, SGroup* sgroup, ScarEntityPBG ebp, ScarPosition position, ScarPosition facing, bool queued )
 	
Send a player command to itself to order squads in the sgroup to construct the building at specific position and facing 

structureBlueprint must be a valid building that can be constructed by the sgroup. This building would cost nothing and does not effect population and availability This is a special command for SCAR use

 
void  Command_PlayerSquadConstructFence( Player* player, SGroup* sgroup, ScarEntityPBG ebp, ScarPosition posStart, ScarPosition posEnd, bool queued )
 	
Send a player command to itself to order squads in the sgroup to construct fences from posStart to posEnd 

structureBlueprint must be a valid building that can be constructed by the sgroup. This building would cost nothing and does not effect population and availability This is a special command for SCAR use

 
void  Command_PlayerSquadConstructField( Player* player, SGroup* sgroup, ScarEntityPBG ebp, ScarPosition posStart, ScarPosition posEnd, bool queued )
 	
Send a player command to itself to order squads in the sgroup to construct a field ranging from posStart to posEnd 

structureBlueprint must be a valid building that can be constructed by the sgroup. This building would cost nothing and does not effect population and availability This is a special command for SCAR use

 
void  Command_PlayerSquadCriticalHit( Player* player, SGroup* sgroup, PlayerCommandType playerCommand, ScarCriticalPBG criticalPBG, float removeAtHealth, bool queued )
 	
Send a player command to itself to act upon all entities in the sgroup with custom parameter and index data (PCMD_CriticalHit) 

This is a special command for SCAR & debug use

 
void  Command_PlayerUpgrade( Player* player, ScarUpgradePBG upgrade, bool instant, bool queued )
 	
Sends an upgrade command to a player 

 
void  Command_Squad( Player* player, SGroup* sgroup, SquadCommandType squadCommand, bool queued )
 	
Send a squad command to a squad group 

SCMD_DefaultAction, SCMD_Move, SCMD_Stop, SCMD_Destroy, SCMD_BuildStructure, SCMD_Capture, SCMD_Attack, SCMD_ReinforceUnit, SCMD_Upgrade, SCMD_CancelProduction SCMD_AttackMove, SCMD_Ability SCMD_Load,SCMD_UnloadSquads, SCMD_DoPlan SCMD_SlotItemRemove, SCMD_InstantReinforceUnit, SCMD_InstantUpgrade

 
void  Command_SquadAbility( Player* player, SGroup* sgroup, ScarAbilityPBG abilityPBG, bool skipCostPrereq, bool queued )
 	
Send a ability command (SCMD_Ability) to a squad 

 
void  Command_SquadAttackMovePos( Player* player, SGroup* sgroup, SquadCommandType squadCommand, ScarPosition target, const char* planName, bool queued )
 	
Send a position ATTACK MOVE command to a squad group with custom data 

 
void  Command_SquadDoCustomPlan( Player* player, SGroup* sgroup, const char* planFile, bool queued )
 	
Send a custom squad AI plan command to the squad to execute the plan specified towards the position 

 
void  Command_SquadDoCustomPlanTarget( Player* player, SGroup* sgroup, ScarPosition pos, const char* planFile, bool queued )
 	
Send a custom squad AI plan command to the squad to execute the plan specified towards the position 

 
void  Command_SquadEntity( Player* player, SGroup* sgroup, SquadCommandType squadCommand, EGroup* target, bool queued )
 	
Send an entity command to a squad group. 

Use this function to isssue an entity-based command to a squad group.<BR/> See Command_Squad for a list of all the possible squadCommands

 
void  Command_SquadEntityAbility( Player* player, SGroup* sgroup, EGroup* target, ScarAbilityPBG abilityPBG, bool skipCostPrereq, bool queued )
 	
Send a entity ability command (SCMD_Ability) to a squad 

 
void  Command_SquadEntityAttack( Player* player, SGroup* sgroup, EGroup* target, bool bCheckFOW, bool bStationary, const char* planName, bool queued )
 	
Send an entity command ATTACK to a squad group. 

Use this function to issue an entity-based command to a squad group with custom FOW check flag. (eg. order a squad to attack a building)<BR/> planName is the name of the custom plan file to execute. Pass in empty string to use the default<BR/> stationary flag uses SCMD_StationaryAttack instead where plan file is ignored and squad does not pursue its target See Command_Squad for a list of all the possible squadCommands

 
void  Command_SquadEntityBool( Player* player, SGroup* sgroup, SquadCommandType squadCommand, EGroup* target, bool cmdparam, bool queued )
 	
Send a entity command to a squad group with custom BOOLEAN data 

 
void  Command_SquadEntityExt( Player* player, SGroup* sgroup, SquadCommandType squadCommand, EGroup* target, uint32_t cmdparam, bool queued )
 	
Send a entity command to a squad group with custom data 

 
void  Command_SquadEntityLoad( Player* player, SGroup* sgroup, SquadCommandType squadCommand, EGroup* target, bool bOverLoad, bool queued )
 	
Send special squad command to a squad group with squad load parameters 

This is a special command for loading squads into building (entity) holds (SCMD_Load, SCMD_InstantLoad)

 
void  Command_SquadExt( Player* player, SGroup* sgroup, SquadCommandType squadCommand, uint32_t cmdparam, bool queued )
 	
Send a squad command to a squad group with custom data 

 
void  Command_SquadMovePos( Player* player, SGroup* sgroup, ScarPosition target, bool queued, bool reverseMove )
 	
Send a move to position command for a squad group. 

Use this function to issue move orders that require a position to a squad group

 
void  Command_SquadMovePosFacing( Player* player, SGroup* sgroup, ScarPosition target, ScarPosition facing, bool queued, bool reverseMove )
 	
Send a move-facing command to a squad group 

 
void  Command_SquadPos( Player* player, SGroup* sgroup, SquadCommandType squadCommand, ScarPosition target, bool queued )
 	
Send a position command to a squad group. 

Use this function to issue orders that require a position to a squad group (eg. order a squad to move to position, or attack position)<BR/> See Command_Squad for a list of all the possible squadCommands.

 
void  Command_SquadPosAbility( Player* player, SGroup* sgroup, ScarPosition pos, ScarAbilityPBG abilityPBG, bool skipCostPrereq, bool queued )
 	
Send a positional ability command (SCMD_Ability) to a squad 

 
void  Command_SquadPosExt( Player* player, SGroup* sgroup, SquadCommandType squadCommand, ScarPosition target, uint32_t cmdparam, bool queued )
 	
Send a position command to a squad group with custom data 

 
void  Command_SquadPositionAttack( Player* player, SGroup* sgroup, ScarPosition target, bool bCheckFOW, bool bStationary, const char* planName, bool queued )
 	
Send an position command ATTACK to a squad group. 

Use this function to issue an position-based command to a squad group with custom FOW check flag. (eg. order a squad to attack a building)<BR/> planName is the name of the custom plan file to execute. Pass in empty string to use the default<BR/> stationary flag uses SCMD_StationaryAttack instead where plan file is ignored and squad does not pursue its target See Command_Squad for a list of all the possible squadCommands

 
void  Command_SquadSquad( Player* player, SGroup* sgroup, SquadCommandType squadCommand, SGroup* target, bool queued )
 	
Send an squad-based command to a squad group. 

Use this function to issue a squad-based command to a squad group. <BR/> See Command_Squad for a list of all the possible squadCommands

 
void  Command_SquadSquadAbility( Player* player, SGroup* sgroup, SGroup* target, ScarAbilityPBG abilityPBG, bool skipCostPrereq, bool queued )
 	
Send a squad ability command (SCMD_Ability) to a squad 

 
void  Command_SquadSquadAttack( Player* player, SGroup* sgroup, SGroup* target, bool bCheckFOW, bool bStationary, const char* planName, bool queued )
 	
Send an squad-based command to a squad group. 

Use this function to issue a squad-based command to a squad group with special boolean flag. (eg. order a squad to attack another squad)<BR/> If bCheckFOW is set to false, the squad would be able to attack other squads hidden in FOW <BR/> planName is the name of the custom plan file to execute. Pass in empty string to use the default<BR/> stationary flag uses SCMD_StationaryAttack instead where plan file is ignored and squad does not pursue its target See Command_Squad for a list of all the possible squadCommands

 
void  Command_SquadSquadExt( Player* player, SGroup* sgroup, SquadCommandType squadCommand, SGroup* target, uint32_t cmdparam, bool queued )
 	
Send a squad command to a squad group with custom data 

 
void  Command_SquadSquadLoad( Player* player, SGroup* sgroup, SquadCommandType squadCommand, SGroup* target, bool bOverLoad, bool queued )
 	
Send special squad command to a squad group with squad load parameters 

This is a special command for loading squads into vehicle (squad) holds (SCMD_Load, SCMD_InstantLoad)

 
void  Command_SquadUpgrade( Player* player, SGroup* sgroup, ScarUpgradePBG upgrade, bool instant, bool queued )
 	
Sends an upgrade command to a squad group. 

 
 

 

DesignerLib
Functions

Void  AutoCinematic( Boolean in/out, Real seconds )
 	
Toggles all cinematic related settings. true = go to cinematic, false = go back to normal 

 
Void  AutoReinforce_AddSGroup( SGroupID sgroup, Variable origin )
 	
Adds an SGroup to the auto-reinforce functions 

 
Void  AutoReinforce_RemoveAll( )
 	
Stops monitoring all squads from the auto-reinforce functions 

 
Void  AutoReinforce_RemoveSGroup( SGroupID sgroup )
 	
Removes an SGroup from the auto-reinforce functions 

 
Void  AutoRetreat_AddSGroup( SGroupID sgroup, MarkerID/Position/EGroupID destination[, Real threshold, LuaFunction onTrigger] )
 	
Sets an sgroup to retreat to the given destination or building once pinned for a certain duration, or reduced to a third of it's original size 

The optional threshold value should be a percentage (between 0.0 and 1.0) - when the member count drops below this, they retreat

 
Void  AutoRetreat_RemoveAll( )
 	
Stops monitoring all squads from the auto-retreat functions 

 
Void  AutoRetreat_RemoveSGroup( SGroupID sgroup )
 	
Removes a squad from being monitored by the auto-retreat functions 

 
Void  BridgeTerritory_Add( EGroupID bridge_egroup, EGroupID bridgepoint, EGroupID bank1point, EGroupID bank2point )
 	
Add a bridge to the Bridge Territory Manager.  

bridgepoint, bank1point and bank2point should be egroups each containing one territory flag

 	Source: [coh2\BIA\root\CoH2\Data\Scar/DesignerLib.scar] (1006) 
References: [Bridge+Territory+Manager]

Void  Ceasefire_AddSGroup( SGroupID sgroup[, LuaFunction function] )
 	
Stops an SGroup from auto-targetting, until one of their members is explicity given an attack order or Ceasefire_RemoveSGroup() is called (at which point they all start firing again) 

You can optionally specify a function that will be called when the ceasefire is broken by the game (rather than by calling Ceasefire_RemoveSGroup)

 
Void  Ceasefire_RemoveSGroup( SGroupID sgroup )
 	
Removes the ceasefire effect from an sgroup. This may already have been removed by issuing an attack order directly to the group. 

 
Void  FireTargettingArtillery( SGroupID/Player caster, SGroupID target, Table targettingData )
 	
Uses targettingData to determine if a target has moved or not and progressively homes-in on it. 

See DesignerLib.scar for details on targettingData values.

 
Void  Game_DefaultGameRestore( )
 	
Restores various aspects of the single player game after loading a mission from a save game 

 
Void  Game_GetGameRestoreCallbackExists( Function callback )
 	
Checks whether a callback  

 
Void  Game_RemoveGameRestoreCallback( Function callback )
 	
Removes a callback from being called on game restore 

 
Void  Game_SetGameRestoreCallback( Function callback )
 	
Adds a function and set of arguments to be automatically called during restore from a saved game. Maxiumum of 9 parameters. Callback will be called like this: Callback(arg[1], arg[2], ...) 

 
Void  Resources_Disable( )
 	
Disables any resource income - useful to stop resources accruing during the opening movie 

 
Void  Resources_Enable( )
 	
Re-enables resource income.  

 
Void  ShootTheSky_AddSyncWeapon( SyncWeaponID syncweapon, PlayerID player )
 	
Forces a sync weapon to shoot at the sky, so long as it's manned by a given player. 

 
Void  ShootTheSky_RemoveAll( )
 	
Stops all sync weapons from going through their "shooting at the sky" routine. 

 
Void  ShootTheSky_RemoveSyncWeapon( SyncWeaponID syncweapon )
 	
Removes a sync weapon from the "shoot at the sky" system. It can then target people again. 

 
Void  SmokeEntrance_Do( MarkerID marker )
 	
Triggers smoke to come in from the map edge, at the position and direction of the given marker 

 
Boolean  Table_Contains( LuaTable OriginalTable, Item item )
 	
Checks if a table contains the specified item  

 
LuaTable  Table_Copy( LuaTable OriginalTable )
 	
Copies the contents of the original table returns a new table with the contents of that table  

 
Item/Table  Table_GetRandomItem( Table table[, Integer numberofitems] )
 	
Returns a random item from a table. You can return multiple items (without duplicates) by passing in an optional number parameter. 

 
Void  TeamWeapon_AddGroup( SGroupID/EGroupID group, Table facingdirections, Integer currentfacing, Boolean threatarrow, Integer turnTime, Integer totalResponses] )
 	
Add a gun to the gun manager. The manager will take care of turning it around to attack units. Turntime is how often the weapon can turn (default 10 seconds), Total Responses is how many times he will adjust before stopping. 

If you pass in an EGroup, it will automatically find or create a corresponding SGroup with sg_ instead of the eg_ prefix.

 	Source: [coh2\BIA\root\CoH2\Data\Scar/DesignerLib.scar] (1126) 
References: [AT+Gun+Manager]

Void  TeamWeapon_RemoveDirections( SGroupID/EGroupID/SyncWeaponID gun )
 	
Remove's the direction settings for a gun, turning it into a fire-at-anything type.  

Use this if you are relocating a gun. Also removes any special first-trigger speech if you have any hooked up, as it may no longer be suitable if you're moving it.

 	Source: [coh2\BIA\root\CoH2\Data\Scar/DesignerLib.scar] (1214) 
References: [AT+Gun+Manager]

Void  TeamWeapon_RemoveGroup( SGroupID/EGroupID/SyncWeaponID gun )
 	
Remove a gun from the gun manager. 

 	Source: [coh2\BIA\root\CoH2\Data\Scar/DesignerLib.scar] (1182) 
References: [AT+Gun+Manager]

 

 

EGroup
Functions

void  EGroup_Add( EGroup* group, Entity* entity )
 	
Adds an entity to the end of a group if the group doesnt already have it. 

 
void  EGroup_AddEGroup( EGroup* group, EGroup* grouptoadd )
 	
Appends the entities in one group to another group.  

All entities from 'grouptoadd' will be added to 'group'.<BR/> If 'group' already contains an entity from 'grouptoadd' it will not be added.<BR/> This function does not clear the contents of 'grouptoadd'.<BR/> Example: Add group2 (0, 10, 11, 22) to group1 (1, 11, 20) --> group1 would now be (1, 11, 20, 0, 10, 22)<BR/>

 
Boolean  EGroup_CanSeeEGroup( EGroupID egroup, EGroupID targetegroup, Boolean all )
 	
Returns true if ALL or ANY entities in a group can see ALL or ANY entities in a given egroup. 

 
Boolean  EGroup_CanSeeSGroup( EGroupID egroup, SGroupID targetsgroup, Boolean all )
 	
Returns true if ALL or ANY entities in a group can see ALL or ANY squads in a given sgroup. 

 
void  EGroup_Clear( EGroup* egroup )
 	
Removes all entities from a group 

 
bool  EGroup_Compare( EGroup* group1, EGroup* group2 )
 	
Returns true if the contents of the two groups are equal. Order of the entities does not matter. 

 
Boolean  EGroup_ContainsBlueprints( EGroupID egroup, BP/Table blueprint, Boolean all )
 	
Check if a group contains ALL or ANY of the blueprints. 

 
Boolean  EGroup_ContainsEGroup( EGroupID egroup1, EGroupID egroup2, Boolean all )
 	
Returns true if EGroup1 contains ANY or ALL of EGroup2 

 
Boolean  EGroup_ContainsEntity( EGroupID egroup, EntityID entity )
 	
Returns true if EGroup contains a particular EntityID 

 
int  EGroup_Count( EGroup* egroup )
 	
Returns the total number of spawned and despawned entities in a group. 

 
int  EGroup_CountAlive( EGroupID egroup )
 	
Get the number of alive entities (both spawned and despawned) 

 
int  EGroup_CountDeSpawned( EGroup* egroup )
 	
Returns the number of despawned entities in a group. 

 
int  EGroup_CountSpawned( EGroup* egroup )
 	
Returns the number of spawned entities in a group. 

 
EGroup*  EGroup_Create( const char* name )
 	
Returns a new entity group with the given name. 

Entity groups are used for buildings and objects such as rocks and trees.<BR/> If you need to issue orders to a group vehicles or units you must use a SquadGroupObs.

 
EGroupID  EGroup_CreateIfNotFound( String egroupname )
 	
Find a entity group from name. Creates a new one with given name if it doesnt exist. 

 
Void  EGroup_CreateKickerMessage( EGroupID group, LocString textid )
 	
Create and display kicker message on the each entity in the egroup to the player 

 
Void  EGroup_DeSpawn( EGroupID egroup )
 	
Despawn all spawned entities in a group. 

 
void  EGroup_Destroy( EGroup* egroup )
 	
Manually destroy a group that you dont need anymore. 

 
Void  EGroup_DestroyAllEntities( EGroupID egroup )
 	
Destroys all spawned and despawned entities in a group. 

Be careful not to confuse this with EGroup_Destroy which destroys the group and NOT the items it contains. This function will destroy spawned and despawned items in a group

 
Void  EGroup_Duplicate( EGroupID egroupid1, EGroupID egroupid2 )
 	
Duplicates an EGroup 

Creates a copy of egroup1 in egroup2. The function will clear egroup2 beforehand if necessary.

 
Void  EGroup_EnableMinimapIndicator( EGroupID egroup, Boolean enable )
 	
Enables or disables the minimap indicator for all entities in a group 

 
Void  EGroup_EnableUIDecorator( SGroupID group, Boolean enable, Boolean enableSelection )
 	
Enable or disable decorators on all entities in the egroup. Sets selection visuals as well unless enableSelection is specified. 

 
bool  EGroup_Exists( const char* name )
 	
Returns true if the entity group with the given name exists 

 
Void  EGroup_Filter( EGroupID egroup, String/ID/Table blueprint, Integer filtertype )
 	
Filters an EGroup by blueprint. 

Blueprints can be provided by name or by ID, and in a table if you want to filter on more than one type. Setting filtertype to FILTER_KEEP results in the group only containing entities of the types listed in the blueprint table. Setting filtertype to FILTER_REMOVE will strip those same entities out and leave those that aren't of the types listed.

 
Void  EGroup_FilterUnderConstruction( EGroupID egroup, Integer filtertype )
 	
Filters an EGroup by construction status. 

Setting filtertype to FILTER_KEEP results in the group only containing those entities that are in the process of being built. Setting filtertype to FILTER_REMOVE will strip those same entities out and leave those that are complete.

 
bool  EGroup_ForEach( EGroup* egroup, LuaBinding::StackVarFunction f )
 	
Call a lua function for each item in a group. Function will recieve (groupid, itemindex, itemid) and should return true to break or false to continue. 

function Rule_Test( )<BR/> <TAB/>local DespawnEntity = function( egroupid, itemindex, entityID )<BR/> <TAB/><TAB/>Entity_Despawn( entityID )<BR/> <TAB/>end<BR/><BR/> <TAB/>EGroup_ForEach( EGroup_FromName("eg_PlayersHQ"), DespawnEntity )<BR/> end<BR/> Note: This function iterates over SPAWNED ENTITIES ONLY.

 
bool  EGroup_ForEachAllOrAny( EGroup* egroup, bool all, LuaBinding::StackVarFunction f )
 	
Call a lua function for each item in a group. Function will receive (groupid, itemindex, itemid) and should return a bool. 

Only use this to TEST conditions on entities. DO NOT use this to perform operations on all entities, since it may not call your function on all entities (due to short circuit evaluation). This is used for checking if ALL or ANY items in a group match a given predicate. (eg. Are all items in a group chaos marines)<BR/> Note: This function iterates over SPAWNED ENTITIES ONLY.

 
bool  EGroup_ForEachAllOrAnyEx( EGroup* egroup, bool all, LuaBinding::StackVarFunction f, bool spawned, bool despawned )
 	
Same as EGroup_ForEachAllOrAny except you have a choice to iterate over spawned entities, despawned entities, or both. 

 
bool  EGroup_ForEachEx( EGroup* egroup, LuaBinding::StackVarFunction f, bool spawned, bool despawned )
 	
Same as EGroup_ForEach except you have a choice to iterate over spawned entities, despawned entities, or both. 

 
EGroup*  EGroup_FromName( const char* name )
 	
Find an entity group with a given name. 

 
Real  EGroup_GetAvgHealth( EGroupID egroup )
 	
Returns the average health of all units in a entity group. 

This uses the "proper" measure of health for panel buildings, so should accurately reflect what the user sees.

 
Entity*  EGroup_GetDeSpawnedEntityAt( EGroup* group, unsigned int index )
 	
Returns the despawned entity at the given index. 

Use EGroup_GetSpawnedEntityAt if you want the spawned items in the group<BR/> Use index 1 to get the first entity in the group.<BR/> It is an error if index > EGroup_GetCountDeSpawned()<BR/>

 
Boolean  EGroup_GetInvulnerable( EGroupID egroup, Boolean all )
 	
Check invulnerablity state for ALL or ANY entity in an entity group. 

Set all param to true to check for ALL or set to false to check for ANY.

 
Void  EGroup_GetLastAttacker( EGroup EGroupVictim, SGroup SGroupAttacker )
 	
Gets the last attacker(s) for all the entities in an EGroup Gets the last attacker for all the squads in an SGroup and stores that in SGroupAttacker 

 
const char*  EGroup_GetName( EGroup* egroup )
 	
Returns the name of a given entity group. 

 
Position  EGroup_GetOffsetPosition( EGroupID egroup, Integer offset, Real value )
 	
Returns a position (a certain distance away) relative to an entity's current position/orientation. see LuaConsts.scar for explanation of 'offset' parameter 

 
ScarPosition  EGroup_GetPosition( EGroup* group )
 	
Returns the center position of an entity group. 

 
EntityID  EGroup_GetRandomSpawnedEntity( EGroup egroupid )
 	
Get a random spawned entity from egroup 

 
Table  EGroup_GetSequence( String name )
 	
Builds a table of EGroupIDs that are named in a sequence. i.e. a name of "eg_building" will find groups "eg_building1", "eg_building2" and so on, up until it looks for a group that isn't there. 

 
Entity*  EGroup_GetSpawnedEntityAt( EGroup* group, unsigned int index )
 	
Returns the spawned entity at the given index. 

Use EGroup_GetDeSpawnedEntityAt if you want the despawned items in the group<BR/> Use index 1 to get the first entity in the group.<BR/> It is an error if index > EGroup_GetCountSpawned()<BR/>

 
EntityID or NIL if none met condition  EGroup_GetSpawnedEntityFilter( EGroup egroupid, function condition(entity) )
 	
Get the first spawned entity from egroup that meets the condition (a function that takes an entity) 

 
Real  EGroup_GetSpread( EGroupID egroup )
 	
Returns the distance from the centre of the group of the entity that furthest out.  

 
Void  EGroup_GetSquadsHeld( EGroupID egroup, SGroupID sgroupRecipient )
 	
Returns an sgroup containing all squads held by any entities in an egroup 

 
Boolean  EGroup_HasUpgrade( EGroupID egroup, UpgradeID upgrade, Boolean all )
 	
Returns whether ANY or ALL entities in an EGroup have the specified upgrade 

 
Void  EGroup_Hide( EGroupID egroup, Bool hide )
 	
Hide or show all entities in an EGroup 

Bool should be true to hide, false to show

 
Void  EGroup_InstantCaptureStrategicPoint( EGroupID egroup, PlayerID player )
 	
Change the ownership of a Strategic Point 

 
Void  EGroup_InstantRevertOccupiedBuilding( EGroupID egroup )
 	
Reverts an occupied building 

 
void  EGroup_Intersection( EGroup* group, EGroup* grouptointersect )
 	
Performs a group intersection.  

Only entities that are in both groups will be added to 'group'.<BR/> The contents of 'grouptointersect' will not be changed.<BR/> Example: group = (1,2,3,4,5,6) grouptointersect = (2,4,6,8,10) --> group will now equal (2,4,6)

 
Boolean  EGroup_IsBurning( EGroupID egroup, Boolean ALL )
 	
Checks if ANY or ALL entities in an egroup are on fire (ignition threshold exceeded) 

 
Boolean  EGroup_IsCapturedByPlayer( EGroupID egroup, PlayerID playerId, Boolean all )
 	
Returns true if all or any strategic points in a group have been captured. Use ANY or ALL. 

This function will ignore all entities that cannot be captured and will return false if no entities in the group can be captured.

 
Boolean  EGroup_IsCapturedByTeam( EGroupID egroup, TeamID teamId, Boolean all )
 	
Returns true if all or any strategic points in a group have been captured. Use ANY or ALL. 

This function will ignore all entities that cannot be captured and will return false if no entities in the group can be captured.

 
Boolean  EGroup_IsDoingAttack( EGroupID egroup, Boolean all, Float time )
 	
Returns true if ALL or ANY entities are attacking within the time 

 
Boolean  EGroup_IsEmpty( EGroupID egroup )
 	
Returns true if a named entity group contains no spawned or despawned entities 

 
Void  EGroup_IsHoldingAny( EGroupID egroup )
 	
Returns whether any entity in an EGroup has a hold on anything 

 
Boolean  EGroup_IsInCover( EGroupID egroup, Boolean all )
 	
Returns true if ALL or ANY entities are in cover. 

 
Boolean  EGroup_IsMoving( EGroupID egroupid, Boolean all )
 	
Returns true if ANY or ALL entities in an EGroup are moving. 

 
Bool  EGroup_IsOnScreen( PlayerID player, EGroupID group, Bool all[, Float percent] )
 	
Returns true if ANY or ALL (use those keywords) of the enities in the group are present onscreen. You can pass in a percentage of the screen to check, so 0.8 would be a centered rectangle occupying 80% of the screen. 

 
Boolean  EGroup_IsProducingSquads( EGroupID egroup, Boolean all )
 	
Returns true if ALL or ANY entities in a group are currently producing squads 

Set all to true to check for ALL or set to false to check for ANY

 
Boolean  EGroup_IsSpawned( EGroupID egroup, Boolean ALL )
 	
Checks if ANY or ALL entities in an group are currently spawned or not. 

 
Boolean  EGroup_IsUnderAttack( EGroupID egroup, Boolean all, Float time )
 	
Returns true if ALL or ANY entities are under attack within the time 

 
Bool  EGroup_IsUnderAttackByPlayer( EGroupID group, PlayerID attackerplayer, Float duration )
 	
Check if the entities are attacked by the player 

 
Boolean  EGroup_IsUnderAttackFromDirection( EGroupID egroup, Boolean all, Integer/Table offset, Float time )
 	
Returns true if ALL or ANY entities are under attack from a direction within the time. see LuaConsts.scar for types of directions. you can pass in a table of offsets 

 
Boolean  EGroup_IsUsingAbility( EGroupID egroup, Boolean ALL )
 	
Checks if ANY or ALL squads within an EGroup are using an ability 

also used for emplacements/entities that are built but function through the use of squads. Does not check WHAT ability a squad is using.

 
Void  EGroup_Kill( EGroupID egroup )
 	
Kill all entities in an EGroup 

 
Void  EGroup_NotifyOnPlayerDemolition( EGroupID id, LuaFunction function )
 	
Calls a function when any entity in an EGroup gets destroyed by the player clicking the "Detonate me" button 

 
void  EGroup_Remove( EGroup* group, Entity* entity )
 	
Removes an entity from a group. 

 
Void  EGroup_RemoveDemolitions( EGroupID egroup )
 	
Removes all demolition charges on an egroup 

 
Void  EGroup_RemoveGroup( SGroupID group, SGroupID grouptoremove )
 	
Remove from the first SGroup all squads contained in the second SGroup. SGroup2 remains untouched. 

 
Void  EGroup_RemoveUpgrade( EGroupID egroup, UpgradeBlueprint/Table upgrade )
 	
Removes upgrade(s) from an egroup 

 
Void  EGroup_ReSpawn( EGroupID egroup )
 	
Respawn all despawned entities in a group. 

 
Void  EGroup_SetAnimatorAction( EGroupID egroup, String actionName )
 	
Trigger animation action for an EGroup. Please only use this for simple animations 

 
Void  EGroup_SetAnimatorEvent( EGroupID egroup, String eventName )
 	
Set animation event for an EGroup. Please only use this for simple animations 

 
Void  EGroup_SetAnimatorState( EGroupID egroup, String stateMachineName, String stateName )
 	
Set animation state of a state machine for an EGroup. Please only use this for simple animations 

 
Void  EGroup_SetAnimatorVariable( EGroupID egroup, String variableName, Real value )
 	
Set animation variable value for an EGroup. Please only use this for simple animations 

 
Void  EGroup_SetAutoTargetting( EGroupID group, String hardpoint, Bool enable )
 	
Sets whether a weapon to auto-target things or not 

 
Real  EGroup_SetAvgHealth( EGroupID egroup, Real healthPercent )
 	
Sets the health of each unit in an entity group to a given percent [0.0, 1.0]. 

 
Void  EGroup_SetCrushable( EGroupID egroup, Boolean crushable )
 	
Overrides crushable behavior for an egroup 

 
Void  EGroup_SetDemolitions( PlayerID player, EGroupID egroupid[, Integer numcharges] )
 	
Instantly wires a building for demolitions 

 
Void  EGroup_SetHealthMinCap( EGroupID egroup, float minhealth )
 	
Set the minimum health for this entity 

This is usually set to zero, any higher value prevents the entity from having its health reduced below this given value

 
Void  EGroup_SetInvulnerable( EGroupID egroup, Boolean enabled[, Float reset_time] )
 	
Enable/Disable invulnerablity for an entire entity group. Use true and false for simple on/off, or use a number between 0.0 and 1.0 for more precise control on how much damage an entity can take before it takes no more. 

The optional reset_time is used to automatically remove invulnerability after a set time. If invulnerable, both health and critical damage are disabled.

 
Void  EGroup_SetPlayerOwner( EGroup egroup, PlayerID owner )
 	
Changes the player owner for all spawned and despawned entities of an EGroup. 

Strategic/capturable point does not support setting player owner directly

 
Void  EGroup_SetRallyPoint( EGroupID egroup, Position target )
 	
Set the rally point for this entity 

This is usually set to zero, any higher value prevents the entity from having its health reduced below this given value

 
Void  EGroup_SetRecrewable( EGroupID sgroup, Boolean recrewable )
 	
Sets all entities in an egroup to be recrewable or not when abandoned 

 
Void  EGroup_SetSelectable( EGroupID egroup, Bool selectable )
 	
Set player selectable state of entities in the egroup 

 
Void  EGroup_SetSharedProductionQueue( EGroupID egroup, Boolean enable )
 	
Enables shared team production on a building (teammates can build using THEIR resources) 

 
Void  EGroup_SetStrategicPointNeutral( EGroupID egroup )
 	
Sets a strategic point to neutral (not owned by any team)  

 
Void  EGroup_SetWorldOwned( EGroupID egroup )
 	
Makes an egroup neutral 

 
EGroupID  EGroup_Single( EGroupID egroup, entityID entity )
 	
Creates an entity group containing a single entity 

Creates an EGroup containing just one entity, creating the group if it doesn't exist and clearing it if it does. It returns the name of the EGroup.

 
Boolean  SGroup_HasEntityUpgrade( EGroupID egroup, UpgradeID upgrade, Boolean all )
 	
Returns true if ANY or ALL of the squad's entities have the specified upgrade 

 
 

 

Encounter
Functions

Table  Ai:GetEncountersBySGroup( SGroup sgroup, ANY/ALL all )
 	
Finds all encounters that contain ANY or ALL squads within the given sgroup. 

 
Table  Ai:GetEncountersBySquad( SGroup sgroup, ANY/ALL all )
 	
Finds all encounters that contain ANY or ALL squads within the given sgroup. 

 
Void  AI_DisableAllEncounters( Void  )
 	
Disables all encounters 

 
Void  AI_EnableAllEncounters( Void  )
 	
Enables all encounters 

 
Table  AI_GetActiveEncounters( Void  )
 	
Returns a table with all active (not dead) encounters. 

 
Int  AI_GetNumEncounters( Void  )
 	
Returns the number of alive encounters currently managed by the AI manager. 

 
Boolean  AI_IsMatchingDifficulty( Int/Table difficultyList )
 	
Returns True if the current AI_Manager difficulty matches any in a given list. 

 
Void  AI_OverrideDifficulty( Int level )
 	
Overrides the current difficulty setting (only for the AI Manager). Pass 'nil' to reset to Game_GetSPDifficulty() value 

 
Void  AI_RemoveAllEncounters( Void  )
 	
Disables all encounters, then clears out the encounter list 

 
Void  AI_SetDebugLevel( Void  )
 	
Set the level of debug information shown but Ai:Print(). 

 
Void  AI_SetStaggeredSpawnDelay( Float delay )
 	
Sets the delay to use when using staggeredSpawn for encounters. The new interval will take effect immediately. 

 
Void  AI_ToggleDebugData( Void  )
 	
Toggle encounter/goal debug information on screen. 

 
Void  AI_ToggleDebugPrint( Void  )
 	
Toggle printing console debug information for encounters. 

 
Void  AIAbilityGoal_AdjustDefaultGoalData( Table additionalDefaultGoalData )
 	
Adjust default goal data for ability goals. Sets the default GoalData to the current defaults plus additionalDefaultGoalData; any values specified are used for unspecified encounter ability goal values. 

 
Void  AIAbilityGoal_SetDefaultGoalData( Table defaultGoalData )
 	
Set default goal data for ability goals. defaultGoalData is cloned; any values specified are used for unspecified encounter ability goal values. 

 
Void  AIAbilityGoal_SetModifyGoalData( Table modifyGoalData )
 	
Set modify goal data for ability goals. modifyGoalData is cloned; values specified via keyname_Multiplier are used for the numeric keyname encounter ability goal value. 

 
Void  AIAbilityGoal_SetOverrideGoalData( Table overrideGoalData )
 	
Set override goal data for ability goals. overrideGoalData is cloned; any values specified are used for encounter ability goal values. 

 
Void  AIAttackGoal_AdjustDefaultGoalData( Table additionalDefaultGoalData )
 	
Adjust default goal data for attack goals. Sets the default GoalData to the current defaults plus additionalDefaultGoalData; any values specified are used for unspecified encounter attack goal values. 

 
Void  AIAttackGoal_SetDefaultGoalData( Table defaultGoalData )
 	
Set default goal data for attack goals. defaultGoalData is cloned; any values specified are used for unspecified encounter attack goal values. 

 
Void  AIAttackGoal_SetModifyGoalData( Table modifyGoalData )
 	
Set modify goal data for attack goals. modifyGoalData is cloned; values specified via keyname_Multiplier are used for the numeric keyname encounter attack goal value. 

 
Void  AIAttackGoal_SetOverrideGoalData( Table overrideGoalData )
 	
Set override goal data for attack goals. overrideGoalData is cloned; any values specified are used for encounter attack goal values. 

 
Void  AIBaseGoal_AdjustDefaultGoalData( Table additionalDefaultGoalData )
 	
Adjust default goal data. Sets the default GoalData to the current defaults plus additionalDefaultGoalData; any values specified are used for unspecified encounter goal values. 

 
Void  AIBaseGoal_SetDefaultGoalData( Table defaultGoalData )
 	
Set default goal data. defaultGoalData is cloned; any values specified are used for unspecified encounter goal values. 

 
Void  AIBaseGoal_SetModifyGoalData( Table modifyGoalData )
 	
Set modify goal data. modifyGoalData is cloned; values specified via keyname_Multiplier are used for the numeric keyname encounter goal value. 

 
Void  AIBaseGoal_SetOverrideGoalData( Table overrideGoalData )
 	
Set override goal data. overrideGoalData is cloned; any values specified are used for encounter goal values. 

 
Void  AIDefendGoal_AdjustDefaultGoalData( Table additionalDefaultGoalData )
 	
Adjust default goal data for defend goals. Sets the default GoalData to the current defaults plus additionalDefaultGoalData; any values specified are used for unspecified encounter defend goal values. 

 
Void  AIDefendGoal_SetDefaultGoalData( Table defaultGoalData )
 	
Set default goal data for defend goals. defaultGoalData is cloned; any values specified are used for unspecified encounter defend goal values. 

 
Void  AIDefendGoal_SetModifyGoalData( Table modifyGoalData )
 	
Set modify goal data for defend goals. modifyGoalData is cloned; values specified via keyname_Multiply are used for the numeric keyname encounter defend goal value. 

 
Void  AIDefendGoal_SetOverrideGoalData( Table overrideGoalData )
 	
Set override goal data for defend goals. overrideGoalData is cloned; any values specified are used for encounter defend goal values. 

 
Void  AIMoveGoal_AdjustDefaultGoalData( Table additionalDefaultGoalData )
 	
Adjust default goal data for move goals. Sets the default GoalData to the current defaults plus additionalDefaultGoalData; any values specified are used for unspecified encounter move goal values. 

 
Void  AIMoveGoal_SetDefaultGoalData( Table defaultGoalData )
 	
Set default goal data for move goals. defaultGoalData is cloned; any values specified are used for unspecified encounter move goal values. 

 
Void  AIMoveGoal_SetModifyGoalData( Table modifyGoalData )
 	
Set modify goal data for move goals. modifyGoalData is cloned; values specified via keyname_Multiply are used for the numeric keyname encounter move goal value. 

 
Void  AIMoveGoal_SetOverrideGoalData( Table overrideGoalData )
 	
Set override goal data for move goals. overrideGoalData is cloned; any values specified are used for encounter move goal values. 

 
Void  Encounter:AddSgroup( Void  )
 	
Adds an sgroup to an encounter 

 
Void  Encounter:ClearGoal( Void  )
 	
Clears the current goal. 

 
Encounter  Encounter:ConvertSgroup( SGroup squadgroup )
 	
Create a new encounter from an SGroup, with default encounter data 

Encounter player is derived from sgroup; all squads in sgroup must be owned by same player.

 
Encounter  Encounter:Create( EncounterData data[, Bool spawnNow, Bool spawnStaggered] )
 	
Create a new encounter from encounter data. If spawnNow is true, spawns specified units immediately. 

See: http://relicwiki/display/REL/Ai+Encounters

 
Encounter  Encounter:CreateAbility( String name, SBP/Table encUnits, Marker/Pos spawnLoc, EGroup/SGeoup/Marker/Pos encTarget[, Marker/Pos dynamicSpawn, INT moveRange] )
 	
Create a new encounter with a generic Ability goal. 

 
Encounter  Encounter:CreateAttack( String name, SBP/Table encUnits, Marker/Pos spawnLoc, EGroup/SGeoup/Marker/Pos encTarget[, Marker/Pos dynamicSpawn, Marker/INT encRange, Marker/INT encLeash] )
 	
Create a new encounter with a generic Attack goal. 

 
Encounter  Encounter:CreateBasic( String name, Marker/Pos spawnLoc, SBP/Table encUnits[, Marker/Pos dynamicSpawn] )
 	
Create a new basic encounter. 

 
Encounter  Encounter:CreateDefend( String name, SBP/Table encUnits, Marker/Pos spawnLoc, EGroup/SGeoup/Marker/Pos encTarget[, Marker/Pos dynamicSpawn, Marker/INT encRange, Marker/INT encLeash] )
 	
Create a new encounter with a generic Defend goal. 

 
Encounter  Encounter:CreateMove( String name, SBP/Table encUnits, Marker/Pos spawnLoc, EGroup/SGeoup/Marker/Pos encTarget[, Marker/Pos dynamicSpawn, INT moveRange] )
 	
Create a new encounter with a generic Move goal. 

 
Encounter  Encounter:CreatePatrol( String name, SBP/Table encUnits, Marker/Pos spawnLoc, Marker/String encPath[, Marker/Pos dynamicSpawn, INT pathWait, INT pathLoop] )
 	
Create a new encounter with a generic Patrol goal.  

pathLoop can be: LOOP_NONE, LOOP_NORMAL, LOOP_TOGGLE_DIRECTION

 
Void  Encounter:Disable( Void  )
 	
Stops running the encounter and clears the current goal. 

 
Void  Encounter:Enable( Void  )
 	
Starts encounter running (encounters are enabled by default) if it was disabled previously. 

 
GoalData  Encounter:GetGoalData( Void  )
 	
Gets clone of current goal data. May be nil. 

 
SGroup sgroup  Encounter:GetSgroup( Void  )
 	
Gets the encounter's sgroup. Caution: sgroup may be empty 

 
Void  Encounter:RemoveOnDeath( Bool includeUnits )
 	
Clears the encounter's onDeath callback. If includeUnits is set to true, it clears onDeath callbacks for units as well. 

 
Bool  Encounter:RestartGoal( Void  )
 	
If encounter has a goal, but no currently running objective, restarts the goal. 

Returns true if goal was restarted, false otherwise.

 
Void  Encounter:SetGoal( GoalData goalData )
 	
Creates encounter goal from goal data; goals determine unit objectives and behaviours. 

See: http://relicwiki/display/REL/Ai+Goal

 
Void  Encounter:SetGoalOnSuccess( Void  )
 	
Set the goal's OnSuccess callback. 

 
Void  Encounter:SetOnDeath( ScarFn func )
 	
Sets a new onDeath callback for the encounter 

 
Void  Encounter:Spawn( Bool spawnStaggered )
 	
Spawns the units within an. Does nothing if the encounter has already been spawned. 

 
Void  Encounter:UpdateGoal( GoalData goalData )
 	
Sets the goal data for the encounter. If encounter has a goal with a running objective, updates the goal. 

Use GetGoalData() to get

 
Table  MergeClone( Table defaultTable, Table overrideTable )
 	
Merge clones two table (recursively) into a single table combining into a new table allowing for unadulterated use of the data 

 
 

 

Entity
Functions

void  Entity_ApplyCritical( Entity* pEntity, ScarCriticalPBG criticalPBG, float removeAtHealth )
 	
Trigger a critical hit on an entity 

 
void  Entity_BuildingPanelInfo( Entity* pEntity, ScarPosition cam, ScarPosition terrain )
 	
Displays info about the panel that is intersected by the passed in ray 

 
bool  Entity_CanAttackNow( Entity* attacker, ScarPosition target )
 	
Returns whether an entity can attack a target without moving or turning. 

 
void  Entity_CancelProductionQueueItem( Entity* entity, uint32_t index )
 	
Cancels an item in a production queue. Index 0 is the currently producing item. 

 
bool  Entity_CanLoadSquad( Entity* entity, Squad* squad, bool bCheckSquadState, bool bOverload )
 	
Check if the entity can load squad or not 

 
bool  Entity_CanLoadSquadAndAttackCurrentTarget( Entity* entity, Squad* squad, bool bCheckSquadState, bool bOverload )
 	
Check if the entity can load squad and shoot its target after loading (This function should only be called by AI) 

 
bool  Entity_CanSeeEntity( Entity* entity, Entity* target )
 	
Returns true if the distance between a target entity and the source entity is less than it entity's sight distance. There is no LOS or FOW check. 

Try Player_CanSeeEntity() if you care about LOS or FOW.

 
bool  Entity_CanSeeSquad( Entity* entity, Squad* target )
 	
Returns true if the distance between a target squad and the source entity is less than it entity's sight distance. There is no LOS or FOW check. 

Try Player_CanSeeSquad() if you care about LOS or FOW.

 
void  Entity_ClearPostureSuggestion( Entity* entity )
 	
Clears any previous posture suggestions made to an entity 

 
void  Entity_ClearTagDebug( Void  )
 	
Clears the tagged entity used for debugging 

 
void  Entity_CompleteUpgrade( Entity* pEntity, ScarUpgradePBG upgradePBG )
 	
Instantly adds an upgrade to a given entity 

 
Entity*  Entity_Create( ScarEntityPBG ebp, Player* player, ScarPosition pos, ScarPosition toward )
 	
Creates an entity at a given position and assigns it to a given player. 'blueprint' is a string value containing the name of the entity blueprint. This function does not spawn the entity so you will need to call Entity_Spawn to see this entity 

 
Entity*  Entity_CreateENV( ScarEntityPBG ebp, ScarPosition pos, ScarPosition toward )
 	
Creates an entity at a given position and assigns it to a given player. 'blueprint' is a string value containing the name of the entity blueprint. This function spawns the entity so there is no need to call Entity_Spawn 

 
void  Entity_DeSpawn( Entity* entity )
 	
DeSpawn the entity at its current position 

 
void  Entity_Destroy( Entity* entity )
 	
Remove an entity from the world and destroy it. 

 
bool  Entity_DisableBuildingDeath( Entity* pEntity, bool bDisableDeath )
 	
Disables the death of the given entity building, only works for panel based destructible buldings 

 
void  Entity_DoBuildingDamageRay( Entity* pEntity, ScarPosition cam, ScarPosition terrain, size_t dmgType, bool isDestory, float radius )
 	
Damages this entity but only if its a destructible building 

dmgType of 0 is damage accessory, 1 is damage panel, 2 is destroy panel and 3 is destroy radius

 
void  Entity_EnableAttention( Entity* entity, bool attentive )
 	
Sets whether an entity pays attention to its surroundings 

 
void  Entity_EnableProductionQueue( Entity* entity, bool enable )
 	
Sets whether an entity can produce anything (including upgrades) 

 
void  Entity_EnableStrategicPoint( Entity* entity, bool enable )
 	
Sets whether an strategic point is active 

 
void  Entity_ForceConstruct( Entity* e )
 	
Force constructs this entity but only if its a building 

 
Entity*  Entity_FromWorldID( uint32_t id )
 	
Get an entity from a mission editor ID. 

 
EntityStateID  Entity_GetActiveCommand( Entity* entity )
 	
Returns the active entity command. 

 
ScarEntityPBG  Entity_GetBlueprint( Entity* entity )
 	
Returns the entity's blueprint 

 
float  Entity_GetBuildingProgress( Entity* pEntity )
 	
Returns the construction progress (with range [0.0, 1.0] for a given entity. Returns 0.0 if the entity is not a building. 

 
float  Entity_GetCoverValue( Entity* entity )
 	
Get cover safety value from the where the entity is standing. The safety value is number from -.5 to .5. 

Higher value means better cover. If the entity doesn't have cover_ext, value of 0 would be returned

 
uint32_t  Entity_GetGameID( Entity* entity )
 	
Returns the entities unique id in the world 

 
ScarPosition  Entity_GetHeading( Entity* entity )
 	
Returns the heading of the entity. The heading is currently a lua table with three entries (x, y, z) 

 
float  Entity_GetHealth( Entity* entity )
 	
Returns the health of an entity. 

Health will be zero for entities with no health extension.

 
float  Entity_GetHealthMax( Entity* entity )
 	
Returns the max health of an entity. 

Max health will be zero for entities with no health extension.

 
float  Entity_GetHealthPercentage( Entity* entity )
 	
Returns the percentage health, taking into account destructible buildings 

Health will be zero for entities with no health extension nor building destruction

 
Bool  Entity_GetInvulnerable( SquadID squad )
 	
Check if the entity is invulnerable or not 

 
float  Entity_GetInvulnerableMinCap( Entity* entity )
 	
Returns the invulnerable point in terms of percentage 

For buildings, retrieve the percentage value of healthy below which no more panels could be destroyed

 
bool  Entity_GetInvulnerableToCritical( Entity* entity )
 	
get if an entity is invulnerable to critical effects 

 
void  Entity_GetLastAttacker( Entity* entity, SGroup* group )
 	
Find the last squad attacker on this entity. If found, the squad is added to the sgroup 

 
void  Entity_GetLastAttackers( Entity* entity, SGroup* group, float timeSeconds )
 	
Find the squad attackers on this entity from the last seconds specified. If found, the squads are added to the sgroup. Building attackers are ignored 

 
int  Entity_GetMaxCaptureCrewSize( Entity* entity )
 	
Gets the maximum capture crew size from a recrewable entity 

 
Position  Entity_GetOffsetPosition( EntityID entity, Integer offset, Real distance )
 	
Returns a position relative to an entity's current position and orientation. see LuaConsts.scar for explanation of 'offset' parameter. 

 
Player*  Entity_GetPlayerOwner( Entity* entity )
 	
Returns the Player owner of the given entity. Entity MUST NOT be owned by the world. 

Use World_OwnsEntity to make sure entity is not owned by the world before calling this function

 
ScarPosition  Entity_GetPosition( Entity* entity )
 	
Returns the position of the entity. The position is currently a lua table with three entries (x, y, z) 

 
const PropertyBagGroup*  Entity_GetProductionQueueItem( Entity* entity, uint32_t index )
 	
Returns the blueprint for a production queue item with index. 

 
ProductionItemType  Entity_GetProductionQueueItemType( Entity* entity, uint32_t index )
 	
Returns the production type (PITEM_Upgrade, PITEM_Spawn, PITEM_SquadUpgrade, PITEM_SquadReinforce, PITEM_PlayerUpgrade) for a production queue item with index. 

 
uint32_t  Entity_GetProductionQueueSize( Entity* entity )
 	
Returns the number of items in the entities production queue. 

It is an error to call this function on an entity that does not have a production queue.<BR/> Use Entity_HasProductionQueue to check that the entity has a queue.

 
ResourceAmount::ResourceType  Entity_GetResourceType( Entity* entity )
 	
Returns the resource type of this point 

returns RT_Fuel, RT_Munition, RT_Action, RT_Command, RT_Popcap, RT_Invalid. NOTE: only works on player owned points

 
float  Entity_GetSightInnerHeight( Entity* entity )
 	
Returns the inner sight radius for this entity 

Radius will be zero for entities without a sight extension

 
float  Entity_GetSightInnerRadius( Entity* entity )
 	
Returns the inner sight radius for this entity 

Radius will be zero for entities without a sight extension

 
float  Entity_GetSightOuterHeight( Entity* entity )
 	
Returns the outer sight radius for this entity 

Radius will be zero for entities without a sight extension

 
float  Entity_GetSightOuterRadius( Entity* entity )
 	
Returns the outer sight radius for this entity 

Radius will be zero for entities without a sight extension

 
Squad*  Entity_GetSquad( Entity* pEntity )
 	
Returns the Squad for the passed Entity. (May be nullptr) 

 
bool  Entity_GetSquadsHeld( Entity* pEntity, SGroup* sgroup )
 	
Adds squads held by an entity to an SGroup 

 
size_t  Entity_GetTotalPanelCount( Entity* pEntity )
 	
Gets the total number of panels in a building (returns 0 for anything but panel based destructible buldings) 

 
size_t  Entity_GetUndestroyedPanelCount( Entity* pEntity )
 	
Gets the current number of undestroyed panels in a building (returns 0 for anything but panel based destructible buldings) 

 
ScarWeaponPBG  Entity_GetWeaponBlueprint( Entity* entity, int hardPointIndex )
 	
Returns a weapon hardpoint ( 0 indexed ) 

 
size_t  Entity_GetWeaponHardpointCount( Entity* entity )
 	
Returns how many hardpoints an entity has 

 
bool  Entity_HasAnyCritical( Entity* pEntity )
 	
Return true if the entity has any critical applied to it 

 
bool  Entity_HasCritical( Entity* pEntity, ScarCriticalPBG criticalPBG )
 	
Return true if the entity has the given criticalID applied to it 

 
bool  Entity_HasProductionQueue( Entity* entity )
 	
Returns true if an entity has a production queue. 

 
bool  Entity_HasUpgrade( Entity* pEntity, ScarUpgradePBG upgradePBG )
 	
Return true if the entity has purchased the specified upgrade. 

 
void  Entity_InstantCaptureStrategicPoint( Entity* entity, Player* player )
 	
Strategic point will be captured instantly by the team of the supplied player 

 
void  Entity_InstantRevertOccupiedBuilding( Entity* entity )
 	
Reverts an occupied building 

 
uint32_t  Entity_IsAlive( Entity* pEntity )
 	
Returns true if entity is still alive 

 
bool  Entity_IsAttacking( Entity* entity, float time )
 	
Returns true if the entity is attacking within the time 

Time is in seconds

 
bool  Entity_IsBuilding( Entity* e )
 	
Returns true if the given entity is a building 

 
bool  Entity_IsBurning( Entity* e )
 	
Returns true if the given entity is burning (buildings on fire or non-buildings with burn_exts) 

 
bool  Entity_IsCamouflaged( Entity* entity )
 	
Returns whether the entity is camouflaged. 

 
bool  Entity_IsCapturableBuilding( Entity* entity )
 	
Returns true if the entity is a capturable building 

 
bool  Entity_IsCasualty( Entity* entity )
 	
Returns true if entity is a casualty else false 

 
bool  Entity_IsCuttable( Entity* entity )
 	
Returns whether this entity is cuttable 

 
bool  Entity_IsDemolitionReady( Entity* entity )
 	
Returns whether this entity's demolition charges are ready to be detonated 

 
uint32_t  Entity_IsEBPBuilding( ScarEntityPBG ebp )
 	
Returns true if the given blueprint is a building 

 
bool  Entity_IsEBPObjCover( ScarEntityPBG ebp )
 	
Returns true if the given blueprint is objcover 

 
bool  Entity_IsHardpointActive( Entity* entity, int hardPointIndex )
 	
Returns whether a hardpoint is active ( 0 indexed ) 

 
bool  Entity_IsHoldingAny( Entity* entity )
 	
Check if the entity has a hold on anything 

 
Boolean  Entity_IsInCover( EntityID entityId )
 	
Returns true if entity is in cover. 

 
bool  Entity_IsMoving( Entity* pEntity )
 	
Returns whether an entity is moving. 

 
bool  Entity_IsOfType( Entity* entity, const char* type )
 	
Determines if this entity is of the given type. Types are defined in type_ext/unit_type_list 

 
bool  Entity_IsPartOfSquad( Entity* pEntity )
 	
Returns true if the entity is part of a squad 

 
bool  Entity_IsPlane( Entity* pEntity )
 	
Returns whether an entity is a plane (has a flight extension) 

 
bool  Entity_IsSlotItem( Entity* entity )
 	
Return true if the entity is a slot item 

 
bool  Entity_IsSoldier( Entity* pEntity )
 	
Returns whether an entity is a soldier 

 
bool  Entity_IsSpawned( Entity* entity )
 	
if entity is spawned return true 

 
bool  Entity_IsStartingPosition( Entity* entity )
 	
Returns true if the entity is a starting position 

 
bool  Entity_IsStrategicPoint( Entity* entity )
 	
Returns true if the entity is a strategic point. 

 
bool  Entity_IsStrategicPointCapturedBy( Entity* entity, Player* player )
 	
Returns true if strategic point is captured by the team of the player provided. 

 
bool  Entity_IsSyncWeapon( Entity* entity )
 	
Return true if the entity is a team weapon 

 
bool  Entity_IsUnderAttack( Entity* entity, float time )
 	
Returns true if the entity is under attack.  

 
bool  Entity_IsUnderAttackByPlayer( Entity* entity, Player* pAttackerOwner, float time )
 	
Returns true if the entity is under attack by a certain player 

 
bool  Entity_IsUnderAttackFromDirection( Entity* entity, int offset, float timeSeconds )
 	
Returns true if the entity was under attack from a certain direction (8 offset types, see LuaConsts.scar) 

 
bool  Entity_IsValid( uint32_t id )
 	
Check if an entity with the given ID can be found in the world 

 
bool  Entity_IsVaultable( Entity* pEntity )
 	
Returns whether an entity can be vaulted 

 
bool  Entity_IsVehicle( Entity* pEntity )
 	
Returns whether an entity is a vehicle 

 
bool  Entity_IsVictoryPoint( Entity *pEntity )
 	
Returns true if entityID is a victory point 

 
void  Entity_Kill( Entity* entity )
 	
Kill the entity. Sets health to 0, and triggers death effects. 

 
Void  Entity_NotifyOnPlayerDemolition( Entity entity, LuaFunction function )
 	
Calls a function when an entity gets destroyed by the player clicking the "Detonate me" button next to an entity. 

 
void  Entity_RemoveBoobyTraps( Entity* pEntityTarget )
 	
Removes all booby-traps on this entity 

 
void  Entity_RemoveCritical( Entity* pEntity, ScarCriticalPBG criticalPBG )
 	
Remove a critical from a given entity 

 
void  Entity_RemoveDemolitions( Entity* entity )
 	
Removes all demolition charges on an entity 

 
void  Entity_RemoveUpgrade( Entity* entity, ScarUpgradePBG upgrade )
 	
Removes an upgrade from an entity 

 
void  Entity_SetAnimatorAction( Entity* pEntity, const char* actionName )
 	
Trigger animation action for an entity. Please only use this for simple animations 

 
void  Entity_SetAnimatorActionParameter( Entity* pEntity, const char* actionParameterName, const char* actionParameterValue )
 	
Set animation action parameter for an entity. Please only use this for simple animations 

 
void  Entity_SetAnimatorEvent( Entity* pEntity, const char* eventName )
 	
Set animation event for an entity. Please only use this for simple animations 

 
void  Entity_SetAnimatorState( Entity* pEntity, const char* stateMachineName, const char* stateName )
 	
Set animation state of a state machine for an entity. Please only use this for simple animations 

 
void  Entity_SetAnimatorVariable( Entity* pEntity, const char* variableName, float value )
 	
Set animation variable value for an entity. Please only use this for simple animations 

 
void  Entity_SetBuildingVisualFireState( Entity* pEntity, BuildingDestructionExt::BuildingFireState newFireState )
 	
Set the visual fire state of a building (doesn't actually set the building on fire) 

 
void  Entity_SetCrushable( Entity* entity, bool crushable )
 	
Overrides crushable behavior for an entity 

 
void  Entity_SetCrushMode( Entity* entity, CrushExtInfo::CrushMode mode )
 	
Changes the crush mode of a given entity. Entity must have a crush extension. 

 
bool  Entity_SetDemolitions( Player* player, Entity* entity, int numcharges )
 	
Fully wires this entity for demolitions, if it's set up to be demolishable. 'player' is the one that owns the demolitions and can detonate them. 

 
void  Entity_SetEnableCasualty( bool enable, Entity* pEntity )
 	
 
void  Entity_SetHeading( Entity* entity, ScarPosition pos, bool bInterpolate )
 	
Sets the heading of the entity. The position is currently a lua table with three entries (x, y, z) 

 
void  Entity_SetHealth( Entity* entity, float healthPercent )
 	
Set the health of an entity. healthPercent must be in the range [0.0, 1.0]. 

 
Void  Entity_SetInvulnerable( EntityID entity, Bool enable, Float reset_time )
 	
Set invulnerability on the entity. Reset time is in seconds. If it it set, the invulnerability will expire after this time. 

 
void  Entity_SetInvulnerableMinCap( Entity* entity, float minHealthPercentage, float resetTime )
 	
Make an entity invulnerable to physical damage when health is below the minimum health percentage 

resetTime is the time in seconds that vulnerability will be restored.; zero time for reset time means the buff will last forever

 
void  Entity_SetInvulnerableToCritical( Entity* entity, bool invulnerable )
 	
set an entity invulnerable to critical effects. Invulnerable to critical also means that kills a entity will not have effect 

 
void  Entity_SetOnFire( Entity* pEntity )
 	
Sets an object on fire (also works on buildings) 

 
void  Entity_SetPlayerOwner( Entity* entity, Player* owner )
 	
Changes the owner of the given squad. 

This function doesn't work with strategic/capturable point

 
void  Entity_SetPosition( Entity* entity, ScarPosition pos )
 	
Sets the position of the entity. The position is currently a lua table with three entries (x, y, z) 

 
void  Entity_SetProjectileCanExplode( Entity* projectile, bool canExplode )
 	
Sets whether or not a projectile can explode.  

 
void  Entity_SetRecrewable( Entity* entity, bool capturable )
 	
Sets an entity to be recrewable or not when it becomes abandoned 

 
void  Entity_SetSharedProductionQueue( Entity* entity, bool shared )
 	
Enables shared team production on a building (teammates can build using THEIR resources) 

 
void  Entity_SetStrategicPointNeutral( Entity* entity )
 	
Sets a strategic point to neutral (not owned by any team) 

 
void  Entity_SetWorldOwned( Entity* entity )
 	
Makes an entity neutral 

 
void  Entity_SimHide( Entity* entity, bool hide )
 	
Shows/hides the entity in the simulation 

 
void  Entity_Spawn( Entity* entity )
 	
Spawn the entity at its current position 

 
void  Entity_StopAbility( Entity* entity, ScarAbilityPBG ability, bool bEarlyExit )
 	
Abruptly stops an active ability 

 
void  Entity_SuggestPosture( Entity* entity, unsigned posture, float duration )
 	
Suggests a posture to an entity, lasting the passed duration 

Posture of 0 is prone, 1 is kneel/crouch, and 2 is standing. Duration is in seconds, negative means indefinate.

 
bool  Entity_SupportsDemolition( Entity* entity )
 	
Returns whether this entity is set up to have demolitions placed on it 

 
void  Entity_TagDebug( Entity* entity )
 	
Tags the entity to be used for debugging 

 
void  Entity_VisHide( Entity* pEntity, bool bHide )
 	
Hides or shows an entity visually. 

 
void  Misc_DoWeaponHitEffectOnPosition( ScarPosition pos, ScarWeaponPBG weaponPBG, bool penetrated )
 	
Do weapon hit effect on the ground 

WeaponID is the property bag group id; if penetrated is set to false, deflection effect would be played instead

 
float  Misc_GetTerrainHeight( ScarPosition p )
 	
Returns the terrain height at the top-down co-ordinate specified (for terrain entities can walk on only) 

 
void  Misc_ToggleEntities( Void  )
 	
Hide all world entities for NIS performance debugging. 

 
void  ModMisc_MakeCasualtyAction( Entity* pTargetEntity )
 	
Make the passed entity a casualty by triggering the MakeCasualtyAction 

 
void  ModMisc_MakeWreckAction( Entity* pTargetEntity )
 	
Make the passed entity a wreck by triggering the MakeWreckAction 

 
void  ModMisc_OOCAction( Entity* pTargetEntity )
 	
Make the passed entity go out of control 

Triggers an OutOfControlAction on the unit. Does not trigger any actions associated with an OOC weapon hit critical, just the OOC action.

 
void  UI_EnableEntityDecorator( Entity* entity, bool enabled )
 	
Turn on or off entity decorator. The default is decorator enabled. 

 
void  UI_EnableEntityMinimapIndicator( Entity* entity, bool enabled )
 	
Turn on or off entity minimap indicator. The default is enabled. 

 
void  UI_EnableEntitySelectionVisuals( Entity* entity, bool enabled )
 	
Turn on or off entity selection visuals. The default is visuals enabled. 

 
void  UI_EnableSquadDecorator( Squad* squad, bool enabled )
 	
Turn on or off squad decorator. The default is decorator enabled. 

 
void  UI_EnableSquadMinimapIndicator( Squad* squad, bool enabled )
 	
Turn on or off squad minimap indicator. The default is enabled. 

 
const char*  UI_GetAbilityIconName( ScarAbilityPBG abilityBag )
 	
Returns the icon name for a given ability 

 
 

 

Event System
Functions

EventID  Event_CreateAND( Function callback, Table data, Table events, [Float delay] )
 	
Creates a Callback Event that triggers when ALL of the specified events are triggered. 

Original events are removed.

 
EventID  Event_CreateOR( Function callback, Table data, Table events, [Float delay] )
 	
Creates a Callback Event that triggers when ANY of the specified events are triggered. 

Original events are removed.

 
EventID  Event_ElementOnScreen( Function callback, Table data, PlayerID player, Marker/Pos/SGroup/EGroup element, [ANY/ALL all, Float percent, bool canSee, Float delay] )
 	
Callback given callback function with data, when the given squad/entity/position is on screen.  

Callback data parameter is agumented with: _player = PlayerID player, _element = SGroup/EGroup element

 
EventID  Event_EncounterIsDead( Function callback, Table data, Table!encID [, Float delay] )
 	
Trigger a Callback when an encounter is killed.  

Callback parameter data augmented with: _encounterID, the encounter's reference

 
BOOL  Event_Exists( EventID eventID )
 	
checks to see if the given event currently exists 

 
EventID  Event_GroupBurning( Function callback, Table data, EGroup/Entity group/entityID[, Float delay] )
 	
Callback given callback function with data, when the egroup is burning  

Callback parameter data augmented with: _group = EGroup/Entity group/entityID

 
EventID  Event_GroupIsDead( Function callback, Table data, EGroup/SGroup group[, Float delay, Boolean retreating] )
 	
Callback given callback function with data, when group is dead (empty).  

Callback parameter data augmented with: _group = EGroup/SGroup group. Optional Retreating param will check if the unit is retreating as an alternate (for team weapons)

 
EventID  Event_GroupIsNotPinned( Function callback, Table data, SGroup group[, bool ANY/ALL, Float delay] )
 	
Callback given callback function with data, when group is not pinned  

Callback parameter data augmented with: _group = SGroup group. Note: being suppressed counts as not being pinned

 
EventID  Event_GroupIsNotSuppressed( Function callback, Table data, SGroup group[, bool ANY/ALL, Float delay] )
 	
Callback given callback function with data, when group is not suppressed.  

Callback parameter data augmented with: _group = SGroup group. Note: being pinned counts as not being suppressed.

 
EventID  Event_GroupIsPinned( Function callback, Table data, SGroup group[, bool ANY/ALL, Float delay] )
 	
Callback given callback function with data, when group is pinned  

Callback parameter data augmented with: _group = SGroup group.

 
EventID  Event_GroupIsSuppressed( Function callback, Table data, SGroup group[, bool ANY/ALL, Float delay] )
 	
Callback given callback function with data, when group is suppressed.  

Callback parameter data augmented with: _group = SGroup group.

 
EventID  Event_GroupLeftAlive( Function callback, Table data, EGroup/SGroup group, Int amount[, Float delay] )
 	
Callback given callback function with data, when the amount of entities left in a group drops below amount.  

Callback parameter data augmented with: _group = EGroup/SGroup group, _amount = Int amount

 
EventID  Event_IsDoingAttack( Function callback, Table data, EGroup/SGroup group, ANY/ALL all, Float attackTime[, Float delay] )
 	
Callback given callback function with data, when group is doing an attack in the last attackTime seconds.  

Callback parameter data augmented with: _group = EGroup/SGroup group, _attackTime = Float attackTime

 
EventID  Event_IsEngaged( Function callback, Table data, EGroup/SGroup group, ANY/ALL all, Float attackTime[, Float delay] )
 	
Callback given callback function with data, when group is doing an attack or is under attack in the last attackTime seconds.  

Callback parameter data augmented with: _group = EGroup/SGroup group, _attackTime = Float attackTime

 
EventID  Event_IsHoldingAny( Function callback, Table data, EGroup/SGroup/Entity/Squad target, Boolean empty[, Float delay] )
 	
Callback given callback function with data, when an element is holding anything or nothing.  

Callback parameter data augmented with: _target = EGroup/SGroup/Entity/Squad target, _empty = Bool isEmpty

 
EventID  Event_IsInHold( Function callback, Table data, SGroup/Squad target, Boolean inHold, Float delay] )
 	
Callback given callback function with data, when a target element is in a hold or not.  

Callback parameter data augmented with: _target = SGroup/Squad target, _inHold = Bool inHold

 
EventID  Event_IsSelected( Function callback, Table data, SGroup/Squad/EGroup/entity target, Float delay] )
 	
Callback when a target element is selected.  

Callback parameter data augmented with: _target = EGroup/Entity/SGroup/Squad target, _all = Bool ANY/ALL

 
EventID  Event_IsUnderAttack( Function callback, Table data, EGroup/SGroup group, bool ANY/ALL, Float attackTime[, PlayerID player, Float delay] )
 	
Callback given callback function with data, when group is under attack in the last attackTime seconds.  

Callback parameter data augmented with: _group = EGroup/SGroup group, _attackTime = Float attackTime

 
EventID  Event_NarrativeEventsNotRunning( Function callback, Table data, [Float delay] )
 	
Callback given callback function with data, a narrative event is running.  

 
EventID  Event_NarrativeEventsRunning( Function callback, Table data, [Float delay] )
 	
Callback given callback function with data, when no narrative events are running.  

 
EventID  Event_OnHealth( Function callback, Table data, EGroup/SGroup/Entity/Squad target, Float threshold, Boolean higher[, Float delay] )
 	
Callback given callback function with data, when an element's health falls below (or above if higher is true) given threshold.  

 
EventID  Event_PlayerBuildingCount( Function callback, Table data, PlayerID player, Int!amountOfBuilding [, Float delay] )
 	
Callback given function with data, when player has greater than or equal to amountOfBuildings  

Callback parameter data augmented with: _player = PlayerID player, _amountOfBuildings = Int amountOfBuildings

 
EventID  Event_PlayerCanNotSeeElement( Function callback, Table data, PlayerID player, SquadID/SGroupID/EntityID/EGroupID/Marker/Position!Table element[, ANY/ALL all, Float delay] )
 	
Callback given callback function with data, when the given player can not see the element.  

Callback data parameter is augmented with: _player = PlayerID player, _elements = Table inputElements, _seenElements = Table allSeenElements

 
EventID  Event_PlayerCanSeeElement( Function callback, Table data, PlayerID/TeamID player/team, SquadID/SGroupID/EntityID/EGroupID/Marker/Position!Table element[, ANY/ALL all, Float delay] )
 	
Callback given callback function with data, when the given player can see the element.  

Callback data parameter is augmented with: _player = PlayerID player, _elements = Table inputElements, _seenElements = Table allSeenElements

 
EventID  Event_PlayerDoesntOwnTerritory( Function callback, Table data, PlayerID player, Int/Table/EGroup/Entity sectorID/group/entity[, Float delay] )
 	
Callback given callback function with data, when player owns none of the given territories.  

Callback parameter data augmented with: _player = PlayerID player, _territory = Int/Table sectorID OR EGroup/Entity of a capture point

 
EventID  Event_PlayerOwnsElement( Function callback, Table data, PlayerID player, Entity/EGroup/Squad/SGroup!element [, Float delay] )
 	
Callback given function with data, when player owns the given element 

Callback parameter data augmented with: _player = PlayerID player, _element = Entity/EGroup/Squad/SGroup element

 
EventID  Event_PlayerOwnsTerritory( Function callback, Table data, PlayerID player, SectorID/EGroup/Entity/Table territory[, ANY/ALL all, Float delay] )
 	
Callback given callback function with data, when player owns all given territories.  

Callback parameter data augmented with: _player = PlayerID player, _territory = sectorID/EGroup/Entity/Table of a capture point

 
EventID  Event_PlayerResourceLevel( Function callback, Table data, PlayerID player, ResourceType resourceType, Int amount, [Float delay] )
 	
Callback given callback function with data, when player has more than amount of resourceType.  

Callback data parameter is augmented with: _player = PlayerID player, _resourceType = ResourceType resourceType, _amount = Int amount

 
EventID  Event_PlayerSquadCount( Function callback, Table data, [Bool!areRunning!= false, Float delay] )
 	
Callback given callback function with data, when no narrative events are running.  

 
EventID  Event_Proximity( Function callback, Table data, PlayerID/Squad/Table/TeamID target, Marker/Pos/SectorID/Table/SGroup/EGroup location, REAL range, [ANY/ALL all, Float delay] )
 	
Callback given callback function with data when target enters location. 

Callback data parameter augmented with (could be nil): _result_location = Pos/Marker/Table/SGroup/EGroup/SectorID proximity position.

 
Void  Event_Remove( EventID eventID )
 	
Remove the given callback 

 
Void  Event_RemoveAll( Void  )
 	
Remove all existing callback events. 

 
EventID  Event_TeamBuildingCount( Function callback, Table data, TeamID team, Int!amountOfBuilding [, Float delay] )
 	
Callback given function with data, when player has greater than or equal to amountOfBuildings  

Callback parameter data augmented with: _player = PlayerID player, _amountOfBuildings = Int amountOfBuildings

 
EventID  Event_TeamCanNotSeeElement( Function callback, Table data, TeamID team, SquadID/SGroupID/EntityID/EGroupID/Marker/Position!Table element[, ANY/ALL all, Float delay] )
 	
Callback given callback function with data, when the given team can not see the element.  

Callback data parameter is augmented with: _team = TeamID team, _elements = Table inputElements, _seenElements = Table allSeenElements

 
EventID  Event_TeamCanSeeElement( Function callback, Table data, TeamID team, SquadID/SGroupID/EntityID/EGroupID/Marker/Position!Table element[, ANY/ALL all, Float delay] )
 	
Callback given callback function with data, when the given team can see the element.  

Callback data parameter is augmented with: _team = TeamID team, _elements = Table inputElements, _seenElements = Table allSeenElements

 
EventID  Event_TeamDoesntOwnTerritory( Function callback, Table data, TeamID team, Int/Table/EGroup/Entity sectorID/group/entity[, Float delay] )
 	
Callback given callback function with data, when a team owns none of the given territories.  

Callback parameter data augmented with: _team = TeamID team, _territory = Int/Table sectorID OR EGroup/Entity of a capture point

 
EventID  Event_TeamOwnsElement( Function callback, Table data, TeamID team, Entity/EGroup/Squad/SGroup!element [, Float delay] )
 	
Callback given function with data, when a team owns the given element 

Callback parameter data augmented with: _team = TeamID team, _element = Entity/EGroup/Squad/SGroup element

 
EventID  Event_TeamOwnsTerritory( Function callback, Table data, TeamID team, Int/Table/EGroup/Entity sectorID/group/entity[, ANY/ALL all, Float delay] )
 	
Callback given callback function with data, when a team owns all given territories.  

Callback parameter data augmented with: _team = TeamID team, _territory = Int/Table sectorID OR EGroup/Entity of a capture point

 
EventID  Event_TeamResourceLevel( Function callback, Table data, TeamID team, ResourceType resourceType, Int amount, [Float delay] )
 	
Callback given callback function with data, when a team has a combined amount more than amount of resourceType.  

Callback data parameter is augmented with: _team = TeamID team, _resourceType = ResourceType resourceType, _amount = Int amount

 
EventID  Event_TeamSquadCount( Function callback, Table data, TeamID team, [Bool!areRunning!= false, Float delay] )
 	
Callback given callback function with data, when no narrative events are running.  

 
EventID  Event_Timer( Function callback, Table data, INT/Table delay )
 	
Callback given callback function with data, after a specified delay.  

Delay can be a table containing two numbers and will randomly select a delay from between the two

 
Void  Event_ToggleDebug( Void  )
 	
Toggles the ScarEvent debugger ON and OFF 

 
Void  Event_View( INT eventID )
 	
Calls the view_manager on a ScarEvent with a specific ID. 

 
Void  EventHandler_AssignEncounterGoal( Table data )
 	
Callback helper function for assigning a goal to an Encounter. Name of parameters: 'goalData', 'encounter'. 

Example usage: Event_*(EventHandler_AssignEncounterGoal, {encounter = myEncounter, goalData = myGoalData}, ...

 
Void  EventHandler_ObjectiveComplete( Table data )
 	
Callback helper function for completing an objective. Received parameters: Table objective, Bool showTitle, Bool skipIntel 

Example usage: Event_*(EventHandler_ObjectiveComplete, {objective = objectiveID}, ...

 
Void  EventHandler_ObjectiveStart( Table data )
 	
Callback helper function for starting an objective, name of objective parameter is objective, additional parameters: Bool showTitle, Bool skipIntel 

Example usage: Event_*(EventHandler_ObjectiveStart, {objective = objectiveID, showTitle = true, skipIntel = true}, ...

 
Void  EventHandler_RemoveHint( Table data )
 	
Callback helper function for removing in-game hints. Name of hintpointID parameter is 'hint'. Can receive a table of ID's. 

Example usage: Event_*(EventHandler_RemoveHint, {hint = hp_hintPointID}, ...

 
Void  EventHandler_RemoveMinimapBlip( Table data )
 	
Callback helper function for removing in minimap blips, name of blipID parameter is blip 

Example usage: Event_*(EventHandler_RemoveMinimapBlip, {blip = blipID}, ...

 
Void  EventHandler_RemoveObjectiveUI( Table data )
 	
Callback helper function that removes objective UI elements, name of parameters: objective, element 

Example usage: Event_*(Objective_RemoveUIElements, {element = elementID, objective = objectiveID}, ...

 
Void  EventHandler_Retreat( Table data )
 	
Callback helper function that causes the input group to retreat, name of parameters: group, location, deleteAtMarker, queued 

Example usage: Event_*(EventHandler_Retreat, {group = sg_group, location = mkr_option, deleteAtMarker = true, queued = false}, ...

 
Void  EventHandler_StaggeredRetreat( Table data )
 	
Callback helper function that causes the input group to retreat, name of parameters: group, location, maxTries 

Example usage: Event_*(EventHandler_Retreat, {group = sg_group, location = mkr_option, maxTries = 8}, ...

 
Void  EventHandler_StartIntel( Table data )
 	
Callback helper function for Intel events, name of intel parameter is intel 

Example usage: Event_*(EventHandler_StartIntel, {intel = EVENTS.Speech01}, ...

 
Void  EventHandler_StartNislet( Table data )
 	
Callback helper function for Intel Nislet events, name of intel parameter is intel 

Example usage: Event_*(EventHandler_StartIntel, {intel = EVENTS.Nislet01}, ...

 
Void  EventHandler_StopFlashing( Table data )
 	
Callback helper function for removing UI flashing. Name of ID parameter is flashID 

Example usage: Event_*(EventHandler_StopFlashing, {flashID = myFlashID}, ...

 
 

 

FOW
Functions

void  FOW_PlayerExploreAll( ModPlayer* player )
 	
Explores entire map for one player 

 
void  FOW_PlayerRevealAll( ModPlayer* player )
 	
Reveal FOW for specified player 

 
void  FOW_PlayerRevealArea( ModPlayer* player, ScarPosition pos, float radius, float durationSecs )
 	
Reveals a circular area for the given player over a given duration. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 

Pass in a duration of -1 for indefinite duration ( until unreveal is called )

 
void  FOW_PlayerUnExploreAll( ModPlayer* player )
 	
Unexplores entire map for one player 

 
void  FOW_PlayerUnRevealAll( ModPlayer* player )
 	
Use to undo a FOW_RevealAll for specified player 

 
void  FOW_PlayerUnRevealArea( ModPlayer* player, ScarPosition pos, float radius )
 	
UnReveals a circular area for a given player. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 

 
void  FOW_RevealAll( Void  )
 	
Reveal FOW for all players 

 
void  FOW_RevealArea( ScarPosition pos, float radius, float durationSecs )
 	
Reveals a circular area for all alive players over a given duration. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 

Pass in a duration of -1 for indefinite duration ( until unreveal is called )

 
void  FOW_RevealEGroup( EGroup* group, float durationSecs )
 	
Reveals an entity groups line of sight(LOS) for all alive players over a given duration. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 

Pass in a duration of -1 for indefinite duration ( until the entities are dead )

 
void  FOW_RevealEGroupOnly( EGroup* group, float durationSecs )
 	
Reveals an entity groups in FOW for all alive players over a given duration. 

Pass in a duration of -1 for indefinite duration ( until the entities are dead )

 
void  FOW_RevealEntity( Entity* entity, float durationSecs )
 	
Reveals an entities line of sight (LOS) for all alive players over a given duration. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 

Pass in a duration of -1 for indefinite duration ( until the entity is dead )

 
Void  FOW_RevealMarker( MarkerID marker, Real duration )
 	
Reveals an area the size of a given markers proximity at that markers position for a given amount of time. Pass in a duration of 1 for indefinite duration. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA.  

This function will reveal the FOW for ALL alive players. This does not work with markers with rectangular proximity type

 
void  FOW_RevealSGroup( SGroup* group, float durationSecs )
 	
Reveals a squad groups line of sight(LOS) for all alive players over a given duration. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 

Pass in a duration of -1 for indefinite duration ( until the squads are dead )

 
void  FOW_RevealSGroupOnly( SGroup* group, float durationSecs )
 	
Reveals a squad groups in fow for all alive players over a given duration. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 

Pass in a duration of -1 for indefinite duration ( until the squads are dead )

 
void  FOW_RevealSquad( Squad* squad, float durationSecs )
 	
Reveals a squads line if sight(LOS) for all alive players over a given duration. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 

Pass in a duration of -1 for indefinite duration ( until the entity is dead )

 
void  FOW_RevealTerritory( ModPlayer* player, int sectorID, float durationSecs, bool mustOwn )
 	
Reveals a territory to a player 

 
void  FOW_UnRevealAll( Void  )
 	
Use to undo a FOW_RevealAll 

 
void  FOW_UnRevealArea( ScarPosition pos, float radius )
 	
UnReveals a circular area for all alive players. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA. 

 
Void  FOW_UnRevealMarker( MarkerID marker )
 	
Unreveals an area the size of a given markers proximity at that markers position. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA.  

This does not work with markers with rectangular proximity type

 
void  FOW_UnRevealTerritory( ModPlayer* player, int sectorID )
 	
Unreveals a territory sector 

 
 

 

ID
Functions

LuaTable  EGroup_CreateTable( String format, Integer size )
 	
Returns a table of egroups NOT in the world builder 

See Marker_GetTable for more info on format parameter

 
LuaTable  EGroup_GetWBTable( String format )
 	
Returns a table of egroups from the world builder 

See Marker_GetTable for more info on format parameter

 
LuaTable  Marker_GetNonSequentialTable( String format, Integer size )
 	
Returns a fixed size table of markers from the world builder. Markers that do not exist in the WB, will be nil in the table. This is why we call it 'non-sequential' 

 
LuaTable  Marker_GetTable( String format )
 	
Returns a table of markers from the world builder. Creates as many as it finds 

mkr_table = Marker_GetTable( 'mkr_%d' ) -- creates a table with 3 markers named 'mkr_1', 'mkr_2', and 'mkr_3' (and so on) from the WB<BR/><BR/> mkr_table2 = Marker_GetTable( 'mkr_%02d' ) -- creates a table with 3 markers named 'mkr_01', 'mkr_02', 'mkr_03' (and so on) from the WB<BR/><BR/> mkr_table3 = Marker_GetTable( 'mkr_%03d_patrol' ) -- creates a table with 3 markers named 'mkr_001_patrol', 'mkr_002_patrol' (and so on) from the WB<BR/><BR/>

 
LuaTable  SGroup_CreateTable( String format, Integer size )
 	
Returns a table of sgroups NOT in the world builder 

See Marker_GetTable for more info on format parameter

 
LuaTable  SGroup_GetWBTable( String format )
 	
Returns a table of sgroups from the world builder 

See Marker_GetTable for more info on format parameter

 
 

 

Marker
Functions

bool  Marker_DoesNumberAttributeExist( ScarMarker marker, const char* attrname )
 	
Returns true if a generic number attribute exists for the marker type. 

 
bool  Marker_DoesStringAttributeExist( ScarMarker marker, const char* attrname )
 	
Returns true if a generic string attribute exists for the marker type. 

 
bool  Marker_Exists( const char* name, const char* type )
 	
Returns true if marker exists. If you don't care about the type, pass in an empty string ( "" ) 

 
ScarMarker  Marker_FromName( const char* name, const char* type )
 	
Returns a ScarMarker from the Mission Editor. If you don't care about the type, pass in an empty string ( "" ) 

The type is defined in the markers list of the mission editor when placing markers.<BR/> You will need the result of this function to call any functions that start with Marker_

 
ScarPosition  Marker_GetDirection( ScarMarker marker )
 	
Returns a vector for the marker direction 

 
const char*  Marker_GetName( ScarMarker marker )
 	
Returns the name of a given marker. This value gets set in the Mission Editor. 

 
float  Marker_GetNumberAttribute( ScarMarker marker, const char* attrname )
 	
Returns a generic number attribute defined in a marker. 

Different marker types have different attributes. Note: All marker types have Name and Proximity. Do not use this function to retrieve these values, use Marker_GetName and Marker_GetProximity instead.

 
ScarPosition  Marker_GetPosition( ScarMarker marker )
 	
Returns the position of a given marker. 

 
float  Marker_GetProximityRadius( ScarMarker marker )
 	
Returns the proximity radius of a given marker. Only for marker with proximity type PT_Circle. This value gets set in the Mission Editor. 

 
MarkerObj::ProximityType  Marker_GetProximityType( ScarMarker marker )
 	
Returns the proximity type of a given marker. The possible results are PT_Circle and PT_Rectangle 

 
Table  Marker_GetSequence( String name, String type )
 	
Builds a table of MarkerIDs that are named in a sequence. i.e. a name of "spot" will find markers "spot1", "spot2" and so on, up until it looks for a marker that isn't there. 

 
std::string  Marker_GetStringAttribute( ScarMarker marker, const char* attrname )
 	
Returns a generic string attribute defined in a marker. 

Different marker types can have different attributes.<BR/> Note: All marker types have Name and Proximity. Do not use this function to retrieve these values, use Marker_GetName and Marker_GetProximity instead.<BR/> See markertypes.lua for a listing of all the marker types.

 	Source: [coh2\BIA\src\game\Cross\SimEngine\LuaExports/LuaMarker.cpp] (174) 
References: [MarkerTypes.lua]

const char*  Marker_GetType( ScarMarker marker )
 	
Returns the typename of a given marker. This is the typename from the Mission Editor (name displayed when placing markers) 

 
bool  Marker_InProximity( ScarMarker marker, ScarPosition pos )
 	
Returns true if the given position is in the markers proximity radius or proximity rectangle (depending on the type). 

 
 

 

Modifiers
Functions

Void  Modifier_IsEnabledOnEGroup( EGroupID egroup, String modifier, String modtype, Boolean all, Boolean bEnabledByDefault )
 	
Checks if a modifier is enabled on all or any entities in an egroup 

 
Void  Modifier_Remove( ModID modifier )
 	
Remove an applied modifier.  

 
Void  Modifier_RemoveAllFromEGroup( EGroupID egroup )
 	
Removes all SCAR-applied modifiers for a specific EGroup.  

 
Void  Modifier_RemoveAllFromSGroup( SGroupID sgroup )
 	
Removes all SCAR-applied modifiers for a specific SGroup.  

 
ModID  Modify_AbilityDelayTime( PlayerID player, AbilityID ability, Real scalefactor )
 	
Modifies the initial delay time of an ability 

 
ModID  Modify_AbilityDurationTime( PlayerID player, AbilityID ability, Real scalefactor )
 	
Modifies the duration of an ability 

 
ModID  Modify_AbilityManpowerCost( PlayerID player, AbilityID ability, Real scalefactor[, Integer mathtype] )
 	
Modifies the manpower cost of an ability 

 
ModID  Modify_AbilityMaxCastRange( PlayerID player, AbilityID ability, Real scalefactor )
 	
Modifies the maximum casting range of an ability. NOTE: it assumes that the actions that the ability executes can also handle the modified range 

 
ModID  Modify_AbilityMinCastRange( PlayerID player, AbilityID ability, Real scalefactor )
 	
Modifies the minimum casting range of an ability. NOTE: it assumes that the actions that the ability executes can also handle the modified range 

 
ModID  Modify_AbilityMunitionsCost( PlayerID player, AbilityID ability, Real scalefactor[, Integer mathtype] )
 	
Modifies the munitions cost of an ability 

 
ModID  Modify_AbilityRechargeTime( PlayerID player, AbilityID ability, Real scalefactor )
 	
Modifies the recharge time of an ability 

 
ModID  Modify_Armor( SGroupID/EGroupID group, Real scalefactor[, Boolean exclusive] )
 	
Modifies a squad or entity's armor 

 
ModID  Modify_CaptureTime( EGroupID sgroup, Real scalefactor )
 	
Modifies the capture time of all strategic points in an EGroup. DO NOT USE THIS FUNCTION. 

 
ModID  Modify_DisableHold( EGroupID group, Boolean disable )
 	
Enable or disable hold (garrisoning) for an egroup or sgroup 

 
Void  Modify_Enable_ParadropReinforcements( PlayerID playerId, Boolean enable )
 	
Allows paratroopers to reinforce from the sky. Set to true to enable, false to disable. 

 
ModID  Modify_EntityBuildTime( PlayerID playerId, String ebp, Real scalefactor )
 	
Modifies the time taken to build a particular EBP. This only affects the given player.  

 
ModID  Modify_EntityCost( PlayerID player, String blueprint, Integer resourcetype, Integer addition )
 	
Modifies the cost of an entity for a particular player. Possible resource types are RT_Manpower, RT_Munition, RT_Fuel, RT_Action  

 
ModID  Modify_PlayerExperienceReceived( PlayerID player, Real factor )
 	
Modifies the veterancy experience received by a player 

 
ModID  Modify_PlayerProductionRate( PlayerID sgroup, Real scalefactor )
 	
Modifies the production rate of a player. 

 
ModID  Modify_PlayerResourceCap( PlayerID playerId, Integer resourceType, Real scalefactor[, Integer mathtype] )
 	
Modifies a player's resource cap. Possible resource types are RT_Manpower, RT_Munition, RT_Fuel. Possible math types are MUT_Multiplication, MUT_Addition. 

 
ModID  Modify_PlayerResourceGift( PlayerID playerId, Integer resourceType, Real scalefactor )
 	
Modifies a player's resource bonus received (ie. one-time resource gifts) Possible resource types are RT_Manpower, RT_Munition, RT_Fuel, RT_Action  

 
ModID  Modify_PlayerResourceRate( PlayerID playerId, Integer resourceType, Real scalefactor[, Integer mathtype] )
 	
Modifies a player's incoming resource rate. Possible resource types are RT_Manpower, RT_Munition, RT_Fuel, RT_Action. Possible math types are MUT_Multiplication, MUT_Addition. 

 
ModID  Modify_PlayerSightRadius( PlayerID player, Real scalefactor )
 	
Modifies the sight radius for a player. 

 
ModID  Modify_ProductionRate( EGroupID sgroup, Real scalefactor )
 	
Modifies the production rate of all factories in an EGroup 

 
ModID  Modify_ProjectileDelayTime( PlayerID player, PBG entityBP, Real factor )
 	
Modifies a projectile's delay_detonate_time. 

 
ModID  Modify_ReceivedAccuracy( SGroupID/EGroupID group, Real scalefactor[, Boolean exclusive] )
 	
Modifies the chance of a squad/entity being hit 

 
ModID  Modify_ReceivedDamage( SGroupID/EGroupID group, Real scalefactor[, Boolean exclusive] )
 	
Modifies the damage a squad/entity receives. 

 
ModID  Modify_ReceivedSuppression( SGroupID sgroup, Real scalefactor )
 	
Modifies the rate at which a squad gets suppressed 

 
ModID  Modify_SetUpgradeCost( PlayerID playerId, UpgradeID upgrade, Integer resourceType, Real newCost )
 	
Sets the cost of an upgrade. This only affects the given player 

 
ModID  Modify_SightRadius( SGroupID/EGroupID group, Real scalefactor )
 	
Modifies the sight radius for an egroup or an sgroup. 

 
ModID  Modify_SquadAvailability( PlayerID player, String blueprint, Integer addition )
 	
Modifies the availability limit of a squad type for any given player 

 
ModID  Modify_SquadCaptureRate( SGroupID group, Real scalefactor )
 	
Modifies a squad's rate at which it will capture a strategic point. 

 
ModID  Modify_SquadTypeSightRadius( PlayerID player, String blueprint, Real scalefactor )
 	
Modifies the sight radius of a squad type for any given player 

 
ModID  Modify_TargetPriority( SGroupID/EGroupID group, Integer addition )
 	
Modifies the target priority of a squad or entity group from the attacker. The value is an addition 

 
ModID  Modify_TeamWeapon( SGroupID/EGroupID group, String modifier, Real scalefactor, [String hardpoint] )
 	
Modifies a sync weapon only.  

The hardpoint defaults to "hardpoint_01"

 
ModID  Modify_TerritoryRadius( EGroupID group, Real scalefactor )
 	
Modifies the territory radius for an egroup or an sgroup. 

 
ModID  Modify_UnitSpeed( SGroupID sgroup, Real scalefactor )
 	
Modifies the maximum speed for a vehicle. This has no effect on infantry. 

 
ModID  Modify_UnitVeterancyValue( SGroup/EGroup group, Real scalefactor[, Integer mathtype )
 	
Modifies the Veterancy Experience value of the target SGroup, EGroup, Entity, or Squad. Mathtype is Multiplication by default 

 
ModID  Modify_UpgradeBuildTime( PlayerID playerId, UpgradeID upgrade, Real scalefactor )
 	
Modifies the build time for a particular upgrade. This only affects the given player.  

 
ModID  Modify_Upkeep( PlayerID playerId, Real scalefactor )
 	
Modifies the upkeep for a player  

 
ModID  Modify_VehicleRepairRate( PlayerID player, Real factor, String engineer_entity_blueprint )
 	
Modifies the vehicle repair rate of all a player's engineers 

 
ModID  Modify_VehicleRotationSpeed( EGroupID/SGroupID group, Real factor )
 	
Modifies the vehicle rotation speed 

 
ModID  Modify_VehicleTurretRotationSpeed( SGroupID/EGroupID group, String hardpoint, Real scalefactor )
 	
Modifies the turret rotation speed of a vehicle squad 

The hardpoint should be specified as a string - i.e. "hardpoint_01"

 
ModID  Modify_Vulnerability( EGroupID/SGroupID group, Real scalefactor )
 	
Increases the received accuracy, penetration, and damage on a squad by the scalefactor. For example, a scalefactor of 2 means that the squad gets 2x the received accuracy, 2x the received penetration, and 2x the received damage. 

 
ModID  Modify_WeaponAccuracy( SGroupID/EGroupID group, String hardpoint, Real scalefactor )
 	
Modifies a squad's weapon accuracy. 

The hardpoint should be specified as a string - i.e. "hardpoint_01"

 
ModID  Modify_WeaponBurstLength( SGroupID/EGroupID group, String hardpoint, Real scalefactor )
 	
Modifies a squad's weapon burst length (time). 

The hardpoint should be specified as a string - i.e. "hardpoint_01"

 
ModID  Modify_WeaponBurstRateOfFire( SGroupID/EGroupID group, String hardpoint, Real scalefactor )
 	
Modifies a squad's weapon rate of fire. 

The hardpoint should be specified as a string - i.e. "hardpoint_01"

 
ModID  Modify_WeaponCooldown( SGroupID/EGroupID group, String hardpoint, Real scalefactor )
 	
Modifies a squad's weapon cooldown time. 

The hardpoint should be specified as a string - i.e. "hardpoint_01"

 
ModID  Modify_WeaponDamage( SGroupID/EGroupID group, String hardpoint, Real scalefactor )
 	
Modifies a squad's weapon damage. 

The hardpoint should be specified as a string - i.e. "hardpoint_01"

 
ModID  Modify_WeaponEnabled( SGroupID/EGroupID group, String hardpoint, Boolean enabled )
 	
Enables or disables a weapon hardpoint 

The hardpoint should be specified as a string - i.e. "hardpoint_01"

 
ModID  Modify_WeaponPenetration( SGroupID/EGroupID group, String hardpoint, Real scalefactor )
 	
Modifies a squad's weapon penetration. Does not work on artillery (mortar, nebelwerfer, etc.) 

The hardpoint should be specified as a string - i.e. "hardpoint_01"

 
ModID  Modify_WeaponRange( SGroupID/EGroupID group, String hardpoint, Real scalefactor )
 	
Modifies a squad's weapon range. Does not work on artillery (mortar, nebelwerfer, etc.) 

The hardpoint should be specified as a string - i.e. "hardpoint_01"

 
ModID  Modify_WeaponReload( SGroupID/EGroupID group, String hardpoint, Real scalefactor )
 	
Modifies a squad's weapon reload time. 

The hardpoint should be specified as a string - i.e. "hardpoint_01"

 
ModID  Modify_WeaponScatter( SGroupID/EGroupID group, String hardpoint, Real scalefactor )
 	
Modifies a squad's weapon scatter. 

The hardpoint should be specified as a string - i.e. "hardpoint_01"

 
ModID  Modify_WeaponSuppression( SGroupID/EGroupID group, String hardpoint, Real scalefactor )
 	
Modifies a squad's weapon suppression. Does not work on artillery (mortar, nebelwerfer, etc.) 

The hardpoint should be specified as a string - i.e. "hardpoint_01"

 
 

 

Multiplayer
Functions

Void  MP_BlizzardInit( String blizzard_atmosphere, String default_atmosphere[, Boolean startInBlizzard, Table blizzardData, Boolean useSpeech, String transitionOutAtmosphere] )
 	
Initializes and starts cold weather and blizzard mechanics, taking in atmosphere presets to use in each condition. Uses MP values by default. Defaults to NOT starting in blizzard conditions.  

You need to add import("Systems/BlizzardMulitplayer.scar") to your mission script to use this - it isn't imported by default

 
 

 

Objectives
Functions

PingID  Objective_AddPing( LuaTable objectiveTable, Position pos )
 	
Adds a tactical map ping to an objective 

 
ElementID  Objective_AddUIElements( LuaTable objTable, Position pos[, Boolean ping, LocString hintpointText, Boolean worldArrow, Float/Position objectiveArrowOffset, Entity/Squad/Position objectiveArrowFacing, HintPointActionType actionType, String iconName] )
 	
Adds multiple UI elements on one position. 'pos' can be group/entity/squad/marker. worldArrow adds a 3D arrow which points to the thing in the world. hintpointText adds a hint point that appears on the thing when moused over. If you're adding an arrow or a hintpoint, this thing will be among those potentially pointed to by the 2D HUD arrow. objectiveArrowOffset is an offset applied to the arrow's position (you can specify a height offset or a 3D position offset). 

 
Boolean  Objective_AreAllPrimaryObjectivesComplete( )
 	
Returns whether all primary objectives have been completed. 

 
Void  Objective_Complete( LuaTable objTable[, Boolean bShowTitle, Boolean skipIntel] )
 	
'Completes' an objective. Wrapper function for Objective_SetState with a few other features. If you do not want the objective title to be shown on screen, pass in 'false' for bShowTitle 

Includes managing the blips and triggers the OnComplete() function as defined by the objective table created in the main scar file. SkipIntel will skip the defined INTEL_COMPLTE event.

 
Void  Objective_Fail( LuaTable objTable[, Boolean bShowTitle, Boolean skipIntel] )
 	
'Fails' an objective. Wrapper function for Objective_SetState with a few other features. 

Includes managing the blips and triggers the OnFail() function as defined by the objective table created in the main scar file. SkipIntel will skip the defined INTEL_FAIL event.

 
Integer  Objective_GetCounter( LuaTable objTable )
 	
Returns the current count associated with this objective. 

 
Integer  Objective_GetTimerSeconds( LuaTable objTable )
 	
Returns the amount of seconds on the timer (time remaining or time elapsed, based on the type of timer used) 

 
Void  Objective_IncreaseCounter( LuaTable objTable[, Int amount] )
 	
Increases the counter that is associated with this objective in the UI. You can provide an amount to increase by. 

 
Boolean  Objective_IsComplete( LuaTable objTable )
 	
Returns whether an objective is complete 

 
Boolean  Objective_IsCounterSet( LuaTable objTable )
 	
Returns true if a counter has been set for this objective 

 
Boolean  Objective_IsFailed( LuaTable objTable )
 	
Returns whether an objective is failed 

 
Boolean  Objective_IsStarted( LuaTable objTable )
 	
Returns whether an objective has been started. Completed objectives will return true. 

 
Boolean  Objective_IsTimerSet( LuaTable objTable )
 	
Returns true if a timer has been set for this objective 

 
Boolean  Objective_IsVisible( LuaTable objTable )
 	
Returns whether an objective is visible or not. 

 
Void  Objective_PauseTimer( LuaTable objTable )
 	
Pauses the objective's timer. If a timer has not been set, it does nothing. 

 
ObjectiveID  Objective_Register( LuaTable objTable[, PlayerID/TeamID owner] )
 	
'Registers' an objective. Wrapper function for Objective_Create with a few other features. 

Includes pings as defined by the objective table created in the main scar file. You can pass in a team or player, so that the objective only applies to it.

 
Void  Objective_RemovePing( LuaTable objectiveTable, Integer PingID )
 	
Removes a tactical map ping from an objective 

 
Void  Objective_RemoveUIElements( LuaTable objTable, Integer elementID )
 	
Removes a group of UI elements that were added by Objective_AddUIElements 

 
Void  Objective_ResumeTimer( LuaTable objTable )
 	
Resume the objective's timer. If a timer has not been set, it does nothing. 

 
Void  Objective_SetAlwaysShowDetails( LuaTable objTable, Boolean title, Boolean hud_arrow, Boolean hintpoints )
 	
Sets whether this objective always shows detailed text, the HUD arrow, or the hintpoints. There can only be one objective at a time that forces the HUD arrow to show up. If you pass in 'nil' for hud_arrow then its behavior is not affected. 

 
Void  Objective_SetCounter( LuaTable objTable, Float current[, Float maximum] )
 	
Sets a counter that is associated with this objective in the UI. You can provide a 'maximum' so that it shows up as "1 of 5" 

 
Void  Objective_Show( LuaTable objective_table, Boolean on/off )
 	
Shows or hides an objective from the UI and tactical map 

 
Void  Objective_Start( LuaTable objTable[, Boolean bShowTitle, Boolean skipIntel] )
 	
Shows an objective to the player and activates it 

Includes pings and FOW as defined by the objective table created in the main scar file. SkipIntel will skip the defined INTEL_START event.

 
Void  Objective_StartTimer( LuaTable objTable, Integer direction[, Float initialTime, Float flashThreshold] )
 	
Starts a timer that is associated with this objective in the UI. Use COUNT_DOWN or COUNT_UP for the 'direction' parameter 

 
Void  Objective_StopCounter( LuaTable objTable )
 	
Stops the objective's counter. If a counter has not been set, it does nothing. 

 
Void  Objective_StopTimer( LuaTable objTable )
 	
Stops the objective's timer. If a timer has not been set, it does nothing. 

 
Void  Objective_TogglePings( LuaTable objective_table, Boolean on/off )
 	
Toggles minimap blips on or off. 

 
Void  Objective_UpdateText( LuaTable objTable, LocString title, LocString description[, Boolean bShowTitle] )
 	
Updates the title and description for the objective. If you only want to set one of them, pass in nil for the other 

 
 

 

Operations
Functions

Void  Cmd_StopSquadsOnly( SGroupID sgroup1, Enum squadStateIDtype )
 	
Pass in a group to command to 'stop'. Pass in a squad state to filter by. 

 
Table playerData  OpGameSetup( )
 	
Operation Setup function registers all valid players 

OpGameSetup() should be called by the individual Operation files It creates a master table _Op.PDT meant to be used by Op Utility files only It returns this table so that the Operation file can use and manipulate its own

 
GroupTable table  OpNPC_AddSupportGroup( Table groupTable )
 	
Does things 

 
GroupTable table  OpNPC_AddSyncWpnGroup( Table groupTable )
 	
Does things 

 
GroupTable table  OpNPC_AddTeamWpnGroup( Table groupTable )
 	
Does things 

 
Void  OpNPC_IsGroupActive( Integer groupId )
 	
Does things 

 
Value  OpNPC_Name( Type!value [, Type value] )
 	
Does things 

Does more things

 
Void  OpNPC_RemoveGroup( Integer groupID )
 	
Removes the indicated sub table from the NPC Support Manager 

 
Void  OpNPC_RetreatGroup( Table groupTable, Boolean activeStatus )
 	
Does things 

 
Void  OpNPC_SetGroupActive( Integer groupId, Boolean activeStatus )
 	
Changes the state of the indicated sub table to the value provided 

 
Value  OpPlayer_Action( Type!value [, Type value] )
 	
Does things 

Does more things

 
ModType modTable, PlayerID/Egroup/Sgroup modReciever, Integer scaleValue  OpUtil_AddModifier( )
 	
Applies the indicated modifier type to the specified group or player 

 
Void  OpUtil_AddResourcesToTeam( PlayerID/Team playerORteam, Boolean myTeam )
 	
Works with _Op.PDT, takes a playerID or team and gives that team OR the enemy team lots of resources 

 
Boolean sameTypeFound  OpUtil_AssignSquadSameTypeControlGroup( SgroupID sgroup[, Boolean startWithFirst] )
 	
Trys to assign a squad to a control group with the sametype of squad 

 
void  OpUtil_AssignSquadUnusedControlGroup( SgroupID sgroup[, Boolean startWithFirst] )
 	
Assigns the squads within a sgroup to free control group 

 
Void  OpUtil_ClearPlayZone( MarkerID marker )
 	
Removes the 'Playable Zone' set by OpUtil_SetPlayZone 

 
Boolean isCaptured  OpUtil_EgroupIsCapturedByTeam( EgroupID capturePoint, TeamID playerTeam, Boolean anyAll )
 	
Tracks a syncweapon ID and destroys the weapon if it ever becomes un-crewed 

 
Void  OpUtil_EnemyEGroupArrowManager( ObjectiveID objective, EGroupID target, PlayerID targetPlayer, Table blueprintTable, EGroup buildingGroup, LocID objectiveText, Boolean pingArrow )
 	
Displays an arrow with a text message over a random building that's part of an EGroup of buildings 

Useful when you want to highlight a group of buildings that you want to destroy as an objective but don't want to highlight every building at once.

 
EgroupID/NIL egroupID/nil  OpUtil_FindNearestCapturePoint( SgroupID sgroup, Integer range )
 	
Finds the nearest captureable point to the sgroup  

Will only compare to Registered Captureable Points, will return 'nil' if there are none in range

 
Void  OpUtil_InvulnerableAdd( SGroupID SGroupID, Integer survivorThreshold, [Real percentage] )
 	
Adds an SGroup from a list of units to be tracked for invulnerability 

Specified SGroup will turn invulnerable when it reaches a specified number of survivors OR if the average health of the squad is <20% (under the hood, as a safety measure). If no number is entered the SGroup is assumed to be instantly invulnerable. The percentage is the average health of an sgroup, and will override the number of total members, and thus is optional.

 
Void  OpUtil_InvulnerableRemove( SGroupID SGroupID )
 	
Removes an SGroup from a list of units to be tracked for invulnerability 

If you want an SGroup to not be tracked anymore in terms of invulnerability use this function

 
Void  OpUtil_LogSyncWpn( SGroupID syncweapon )
 	
Tracks a syncweapon ID and destroys the weapon if it ever becomes un-crewed 

 
PlayerID  OpUtil_ReturnEnemyNPC( PlayerID/Team playerORteam )
 	
Works with _Op.PDT, takes a variable and returns an enemy NPC  

 
PlayerID humanPlayer  OpUtil_ReturnHumanPlayer( RaceID/FactionID/Index/TeamID compareVar )
 	
Works with _Op.PDT, takes a variable and returns a Human player  

 
PlayerID npcPlayer  OpUtil_ReturnNPCPlayer( RaceID/FactionID/Index/TeamID compareVar )
 	
Works with _Op.PDT, takes a variable and returns a Non-Human player  

 
RaceID enum  OpUtil_ReturnRace( RaceID/FactionID/Index/PlayerID compareVar )
 	
Works with _Op.PDT, takes a player and returns the race  

 
TeamID integer  OpUtil_ReturnTeam( RaceID/FactionID/Index/PlayerID compareVar )
 	
Works with _Op.PDT, takes a variable and returns the team  

 
Void  OpUtil_SetPlayZone( MarkerID marker )
 	
Sets a 'playable zone' in the area and keeps all Human players within it 

 
Boolean ownsEgroup  OpUtil_TeamOwnsEntity( PlayerID/TeamID owner, EgroupID egroup[, Boolean ANY/ALL )
 	
Checks to see if an egroup is owned by a team 

 
GroupTable table  OpVP_AddPenaltyGroup( Table groupTable )
 	
Does things 

 
Value  OpVP_Name( Type!value [, Type value] )
 	
Does things 

Does more things

 
Void  OpVP_RegisterCaptureablePoints( EgroupID/Table groupID/egroupTable )
 	
Registers a single egroup or a table of egroups as a captureable point 

Tracks the various states of the points, neutral or team owner

 
Void  OpVP_RegisterPointDefense( Table defendTable )
 	
Add a set egroups and defensive formations to defend them  

 
Void  OpVP_RemoveGroup( Integer groupID )
 	
Removes the indicated sub table from the VP Support Manager 

 
Void  UI_PopUpMessage( LocID locstring, LocID locstring[, LabelActionTable table, LabelActionTable table, LabelActionTable!table ] )
 	
Auto-generate a popup message with callbacks. See OpUtil.scar for an example of how to use this function. 

If no buttons are defined it defaults to a 'Close' button that triggers no action.

 
Void  Util_ProductionRestriction( Table sbps/upgs[, Table ebps, LocID!unit Warning, LocID!build Warning] )
 	
Prevents the construction of squads or enities based on blueprint tables passed into the function. 

Calling the function multiple times will stomp any previously data passed into the function.

 
Void  Util_TutorialIntel( Table!intelEventTable![or Actor/String/Button/Sticky/Input] )
 	
Auto-generate a Tutorial Intel Event. Called individually or using the traditional table format. 

See Util_AutoIntel() Takes a table of parameters defining speaker(s)/line(s) or pass in Actor/String/Button/Sticky/Input

 
 

 

Player
Functions

void  Player_AddAbility( ModPlayer* pPlayer, ScarAbilityPBG pAbilityPBG )
 	
Add an ability to a player 

 
void  Player_AddAbilityLockoutZone( ModPlayer* player, ScarAbilityPBG abilityPBG, ScarMarker marker )
 	
Specifies a marker where an ability cannot be used. This only applies to abilities where you use the cursor to pick a location in the world (like a location to paradrop at). 

 
Void  Player_AddResource( PlayerID playerId, Integer resourceType, Real value )
 	
Add resource to player, as opposed to just setting it. Possible resource types are RT_Manpower, RT_Munition, RT_Fuel, RT_Action  

 
SGroupID  Player_AddSquadsToSGroup( PlayerID playerId, String squadgroupName )
 	
For the given player, get all of the squads gathered into a squadgroup of your naming.  

Squads will be added to given squad group. If the given squad group does not exist it will be created.

 
void  Player_AddUnspentCommandPoints( ModPlayer* player, float points )
 	
Gives the player new command points to spent on 

 
Boolean  Player_AreSquadsNearMarker( PlayerID playerid, MarkerID marker )
 	
Returns true if ANY of a players squads are in proximity of a marker 

 
bool  Player_CanCastAbilityOnEntity( ModPlayer* player, ScarAbilityPBG abilityPBG, Entity* targetEntity )
 	
Tests if the player can currently use an ability on target entity 

 
bool  Player_CanCastAbilityOnPlayer( ModPlayer* player, ScarAbilityPBG abilityPBG, ModPlayer* targetPlayer )
 	
Tests if the player can currently use an ability on target player 

 
bool  Player_CanCastAbilityOnPosition( ModPlayer* player, ScarAbilityPBG abilityPBG, ScarPosition targetPosition )
 	
Tests if the player can currently use an ability on target position 

 
bool  Player_CanCastAbilityOnSquad( ModPlayer* player, ScarAbilityPBG abilityPBG, Squad* targetSquad )
 	
Tests if the player can currently use an ability on target squad 

 
Boolean  Player_CanSeeEGroup( PlayerID playerid, EGroupID egroup, Boolean all )
 	
Returns true if a player can see ALL or ANY items in an egroup 

 
bool  Player_CanSeeEntity( const ModPlayer* player, Entity* entity )
 	
Returns true if a player can see a given entity (revealed in FOW) 

 
bool  Player_CanSeePosition( const ModPlayer* player, ScarPosition pos )
 	
Returns true if a player can see a given position. 

 
Boolean  Player_CanSeeSGroup( PlayerID playerid, SGroupID sgroup, Boolean all )
 	
Returns true if a player can see ALL or ANY items in an sgroup 

 
bool  Player_CanSeeSquad( const ModPlayer* player, Squad* squad, bool all )
 	
Returns true if a player can see ALL or ANY units in a given squad (revealed in FOW) 

Set all to true to check that ALL units are visible or set to false to check for ANY.

 
Void  Player_ClearArea( PlayerID player, MarkerID marker, Bool invulnerable )
 	
Any of the player's units in the marker area move out of the area, and can be made invulnerable for a bit whilst they do it 

You can replace the marker with a position and a range - i.e. Player_ClearArea(player, pos, range, invulnerable)

 
void  Player_ClearAvailabilities( ModPlayer* player )
 	
Clears item, command and construction menu availabilities for the player. 

 
void  Player_ClearPopCapOverride( ModPlayer* player )
 	
Clears the pop cap override so that modifiers can take effect again 

 
void  Player_CompleteUpgrade( ModPlayer* pPlayer, ScarUpgradePBG pUpgradePBG )
 	
Finish upgrade for a player 

 
void  Player_DoParadrop( ModPlayer* player, SGroup* sgroup, ScarPosition pos, float dropHeight, float dropDrift, LuaBinding::StackVar blueprint, size_t maxSquadEntityCount, size_t maxDeathOnBuilding )
 	
Do a paradrop with custom parameters for this player. This is similar to regular paradrop ability without any prereq check 

sgroup is the SGroup that the newly created squad would be added to dropHeight is Height in metres the paratroopers are dropped from. dropDrift is Horizontal distance in metres from where the paratroopers are dropped from. blueprint is the blueprint to spawn. It could be squad or entity maxSquadEntityCount is the number of squad members to spawn. 0 means default is used maxDeathOnBuilding is the number of entities allowed to die when landing on buildings Example: local id = SBP.ALLIED_AIRBOURNE Player_DoParadrop( g_player1, sg_soldier1, Marker_GetPosition( marker4 ), 100.0, 10.0, id, 3, 2 )

 
ModPlayer*  Player_FindFirstEnemyPlayer( const ModPlayer* player )
 	
Searches the player list in the world and returns the id of the first enemy player 

 
ModPlayer*  Player_FromId( uint32_t id )
 	
Returns a player given a player id from the ME. 

 
Player::AIType  Player_GetAIType( ModPlayer* pPlayer )
 	
Returns the type of the given player if it is an AI. 

 
Void  Player_GetAll( PlayerID player[, SGroupID sgroup, EGroupID egroup] )
 	
Creates/Clears groups that contain all of a player's units and buildings. Defaults - sg_allsquads and eg_allentities 

Fills an SGroup with all of the given player's squads, and an EGroup with all the player's entities. If you don't provide and groups, then it defaults to using sg_allsquads and eg_allentities.

 
Void  Player_GetAllEntitiesNearMarker( PlayerID playerid, EGroupID egroup, MarkerID/Pos/SectorID position[, Real range] )
 	
Gather together all of a player's entities that are in proximity to a marker, a position, or within a territory sector into an EGroup. The EGroup is cleared beforehand.  

You can override a marker's normal proximity by specifying a range.

 
Void  Player_GetAllSquadsNearMarker( PlayerID player, SGroupID sgroup, MarkerID/Pos/SectorID position[, Real range] )
 	
Gather together all of a player's squads that are in proximity to a marker, a position, or within a territory sector into an SGroup. The SGroup is cleared beforehand.  

You can override a marker's normal proximity by specifying a range.

 
EntityID  Player_GetBuildingID( PlayerID player, BlueprintTable entitytypes )
 	
Returns the entityID of the first player owned building listed in the table. 

This only looks at completed buildings

 
Integer  Player_GetBuildingsCount( PlayerID playerId )
 	
Returns the total number of buildings owned by this player. 

 
Integer  Player_GetBuildingsCountExcept( PlayerID playerId, BlueprintTable exceptions )
 	
Returns the total number of buildings owned by this player (with exclusions). 

 
Integer  Player_GetBuildingsCountOnly( PlayerID playerId, BlueprintTable ebplist )
 	
Returns the number of buildings owned by this player (inclusive). 

 
float  Player_GetCurrentPopulation( const ModPlayer* player, CapType capType )
 	
Use capType CT_Personnel to get current squad cap, CT_Vehicle to get current vehicle cap, CT_Medic to get current medic cap 

 
LocString  Player_GetDisplayName( const ModPlayer* player )
 	
Returns the players UI name. 

 
EGroup*  Player_GetEntities( ModPlayer* player )
 	
Returns an EntityGroupObs containing all the players entities. 

This function returns a 'global' entity group with the name '__Player%dEntities', where %d is the player ID. This means that you should never need to destroy it./n However, if you do destroy it, it will be recreated the next time this function is called.

 
EGroup  Player_GetEntitiesFromType( PlayerID player, String unitType )
 	
Returns an EGroup containing all of the players entities of a specific unit_type (as defined by the type_ext on the entity) 

This function returns a new EGroup to allow tracking of different types.

 
EGroup  Player_GetEntityConcentration( PlayerID player[, Boolean popcapOnly, Table includeBlueprints, Table excludeBlueprints, Boolean bLeastConcentrated, MarkerID/Table onlyInThisMarker] )
 	
Finds the greatest (or least) concentration of entities owned by a player. 

This function is slow, so don't call it very often

 
int  Player_GetEntityCount( const ModPlayer* player )
 	
Returns the number of entities a player currently owns 

 
const char*  Player_GetEntityName( const ModPlayer* player, int index )
 	
Returns the name of an entity a player currently owns 

 
int  Player_GetID( const ModPlayer* player )
 	
Returns the id of the player 

 
float  Player_GetMaxPopulation( const ModPlayer* player, CapType capType )
 	
Use capType CT_Personnel to get max squad cap or CT_VehicleCap to get max vehicle cap. 

 
int  Player_GetNumStrategicPoints( const ModPlayer* p )
 	
Returns the number of strategic points (not objectives) this player owns 

 
int  Player_GetNumVictoryPoints( const ModPlayer* p )
 	
Returns the number of strategic objectives this player owns 

 
Real  Player_GetPopulationPercentage( PlayerID playerid[, Integer captype] )
 	
Gets the current personnel or vehicle population as a percetange of the current max-cap. The captype is either CT_Personnel or CT_Vehicle. 

captype is CT_Personnel by default.

 
int  Player_GetRace( const ModPlayer* player )
 	
Returns the race index for the given player. 

 
const char*  Player_GetRaceName( const ModPlayer* player )
 	
Returns the name of the race for a given player and always in english 

 
ModAlliance::AllianceResult  Player_GetRelationship( const ModPlayer* player1, ModPlayer* player2 )
 	
Returns the relationship between 2 players. 

 
float  Player_GetResource( const ModPlayer* player, ResourceAmount::ResourceType type )
 	
Returns the amount of resources a given player has. 

 
float  Player_GetResourceRate( const ModPlayer* player, ResourceAmount::ResourceType type )
 	
Returns the amount of resources a given player is getting per second. 

 
SGroup  Player_GetSquadConcentration( PlayerID player[, Boolean popcapOnly, Table includeBlueprints, Table excludeBlueprints, Boolean bLeastConcentrated, MarkerID/Table onlyInThisMarker] )
 	
Finds the greatest (or least) concentration of squads owned by a player. 

This function is slow, so don't call it very often

 
int  Player_GetSquadCount( const ModPlayer* player )
 	
Returns the number of squads a player currently owns 

 
SGroup*  Player_GetSquads( const ModPlayer* player )
 	
Returns a SquadGroupObs containing all the players units. 

This function returns a 'global' squad group with the name '__Player%dSquads', where %d is the player ID. This means that you should never need to destroy it./n However, if you do destroy it, it will be recreated the next time this function is called.

 
ScarPosition  Player_GetStartingPosition( const ModPlayer* player )
 	
Returns the starting position for this player 

 
float  Player_GetStrategicPointCaptureProgress( Player* player, Entity* strategicPoint )
 	
Returns a value (-1.0 to 1.0) of how close a point is to being controlled by the team of the player provided 

Progress between -1.0 and 0 means an enemy has progress toward owning a point. Values between 0 and 1.0 represent progress being made toward capture. 1.0 is a team controlled point. -1.0 is an enemy controlled point.

 
int  Player_GetTeam( const ModPlayer* p )
 	
Get the team a player is on 

 
int  Player_GetUnitCount( const ModPlayer* player )
 	
Returns the current number of units the player has. 

 
float  Player_GetUpgradeCost( ModPlayer* player, ScarUpgradePBG upgradePBG, ResourceAmount::ResourceType resourceType )
 	
Returns the cost of an upgrade.  

 
bool  Player_HasAbility( ModPlayer* pPlayer, ScarAbilityPBG pAbilityPBG )
 	
Tests to see if a player has an ability 

 
boolean  Player_HasBuilding( PlayerID player, BlueprintTable entitytypes )
 	
Returns true if this player owns any buildings listed in the table. 

This only looks at completed buildings - use Player_HasBuildingUnderConstruction to see if the player is building something

 
boolean  Player_HasBuildingsExcept( PlayerID playerId, BlueprintTable exceptions )
 	
Returns true if this player owns any buildings. (with exclusions). 

 
boolean  Player_HasBuildingUnderConstruction( PlayerID player, BlueprintTable entitytypes )
 	
Returns true if this player owns any buildings listed in the table currently under construction. 

 
bool  Player_HasCapturingSquadNearStrategicPoint( Player* player, Entity* strategicPoint )
 	
Returns true if the given player has units that are able to capture in the capturable area of the given strategic point 

 
Boolean  Player_HasLost( PlayerID player, LuaTable Blueprints )
 	
Checks to see if a player has lost (if player owns any squads and any buildings contained in blueprints) 

Pass in a table of blueprints of buildings that the player must have in order to be considered "alive". Ambient buildings are already take into consideration since they must be occupied by a squad.

 
bool  Player_HasMapEntryPosition( ModPlayer* player )
 	
Returns whether a player has a map entry position 

 
bool  Player_HasUpgrade( const ModPlayer* pPlayer, ScarUpgradePBG upgradePBG )
 	
Return true if the squad has purchased the specified upgrade. 

 
bool  Player_IsAlive( const ModPlayer* player )
 	
Returns true if player is still alive and false if player is dead. Will error if playerIdx is an invalid index. 

 
Boolean  Player_IsAllied( PlayerID playerId1, PlayerID playerId2 )
 	
Returns true if the players are allied and false if they are not. 

 
bool  Player_IsHuman( ModPlayer* pPlayer )
 	
Returns whether a player is human controlled (local or remote), not dead, and not replaced by an AI 

 
int  Player_NumUpgradeComplete( const ModPlayer* player, ScarSquadPBG upgradePBG )
 	
Returns the number of upgrades that this player has. 

 
Boolean  Player_OwnsEGroup( PlayerID playerid, EGroupID egroup[, Boolean all] )
 	
Returns true if a given player owns ALL or ANY items in a group 

 
Boolean  Player_OwnsEntity( PlayerID playerid, EntityID entity )
 	
Returns true if a given player owns an entity 

 
Boolean  Player_OwnsSGroup( PlayerID playerid, SGroupID sgroup[, Boolean all] )
 	
Returns true if a given player owns ALL or ANY items in a group 

 
Boolean  Player_OwnsSquad( PlayerID playerid, SquadID squad )
 	
Returns true if a given player owns a squad 

 
void  Player_RemoveAbilityLockoutZone( ModPlayer* player, ScarAbilityPBG abilityPBG, ScarMarker marker )
 	
Removes a marker that was previously a lockout zone. 

 
void  Player_RemoveUpgrade( ModPlayer* player, ScarUpgradePBG upgrade )
 	
Removes an upgrade from a player 

 
void  Player_ResetResource( ModPlayer* player, ResourceAmount::ResourceType type )
 	
Reset the resource amount for a given player to zero. Also reset team weapon 

 
Void  Player_RestrictAddOnList( PlayerID playerid, Table addonlist )
 	
Restrict a list of addons. 

list should contain an array of strings to restrict.

 
Void  Player_RestrictBuildingList( PlayerID playerid, Table blueprintlist )
 	
Restrict a list of buildings. 

list should contain an array of strings to restrict.

 
Void  Player_RestrictResearchList( PlayerID playerid, StringTable list )
 	
Restrict a list of research items. 

list should contain an array of strings to restrict.

 
Void  Player_SetAbilityAvailability( PlayerID player, AbilityBlueprint/Table bp, Integer availability )
 	
Sets the availability of an ability. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT 

 
void  Player_SetAllCommandAvailabilityInternal( ModPlayer* player, ModPlayer::Availability availability, LocString reason )
 	
Sets availability of ALL entity, squad and player commands.  

 
Void  Player_SetCommandAvailability( PlayerID player, Integer/Table command, Integer availability )
 	
Sets the availability of entity, squad and player commands. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT 

 
Void  Player_SetConstructionMenuAvailability( PlayerID player, String/Table menuname, Integer availability )
 	
Sets the availability of a construction menu. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT 

 
void  Player_SetDefaultSquadMoodMode( ModPlayer* pPlayer, SquadCombatBehaviourExt::MoodMode mood )
 	
Set default squad mood mode which can be overrided by squad level mood mode settings 

 
Void  Player_SetEntityProductionAvailability( PlayerID player, EntityBlueprint/Table bp, Integer availability )
 	
Sets the availability of an entity production item. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT 

 
void  Player_SetHeatGainRate( ModPlayer* player, float gainRatePerSecond )
 	
Set the heat gain rate per second for this player. Heat is gained when near a heat source or garrisoned. 

 
void  Player_SetHeatLossRate( ModPlayer* player, float lossRatePerSecond )
 	
Set the heat loss rate per second for this player. Heat is lost when not garrisoned and not near a heat source and not in valid cover. A value of 0 turns off the Cold System for all squads belonging to this player. It will also reset all squads to the default heat level. 

 
Void  Player_SetMaxCapPopulation( PlayerID playerid, Integer captype, Integer newcap )
 	
Sets the current personnel or vehicle max-cap for a player. The captype is either CT_Personnel or CT_Vehicle (you can't adjust Medic caps just yet). 

you will have to call Player_SetMaxPopulation to adjust the current max population to do this.

 
Void  Player_SetMaxPopulation( PlayerID playerid, Integer captype, Integer newcap )
 	
Sets the current personnel or vehicle cap for a player. The captype is either CT_Personnel or CT_Vehicle (you can't adjust Medic caps just yet). 

Note that any modifiers that adjust the current cap will be applied on top of this. Also note, the current cap cannot go higher than the max cap.

 
void  Player_SetPopCapOverride( ModPlayer* player, float personnel )
 	
Sets a pop cap override that ignores any modifiers. 

 
void  Player_SetResource( ModPlayer* player, ResourceAmount::ResourceType type, float amt )
 	
Set the resource amount for a given player. Ignores income cap and resource sharing. 

 
Void  Player_SetSquadProductionAvailability( PlayerID player, SquadBlueprint/Table bp, Integer availability )
 	
Sets the availability of a squad production item. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT 

 
Void  Player_SetUpgradeAvailability( PlayerID player, UpgradeBlueprint/Table bp, Integer availability )
 	
Sets the availability of an upgrade. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT 

 
Void  Player_SetUpgradeCost( PlayerID player, UpgradeID upgrade, Real manpower, Real fuel, Real munition, Real action, Real command )
 	
Sets the cost of an upgrade. 

 
Entity*  Player_SpawnGlider( ModPlayer* player, ScarEntityPBG glider, ScarPosition start, ScarPosition end )
 	
Spawns a glider and returns it 

 
void  Player_StopAbility( ModPlayer* player, ScarAbilityPBG ability, bool bEarlyExit )
 	
Abruptly stops an active ability 

 
Void  Player_StopEarningActionPoints( PlayerID player )
 	
Prevents a player from earning any action points (and by extention, command points) 

 
void  Player_Triangulate( ModPlayer* player, SGroup* squads, EGroup* eg )
 	
Returns the enemy squads and entities within a player's radio beacons. Radio beacons are shared among team members. 

 
 

 

Presentation
Functions

Void  Actor_Clear( ActorTable actor )
 	
Clear ties between an actor and any units 

 
Void  Actor_PlaySpeech( ActorTable actor, Integer locID[, Boolean continueButton, Boolean stickySubtitle, Boolean blockInput] )
 	
Plays a speech event for a given actor WITH a portrait and subtitle 

Be VERY careful how you use the 'blockInput' parameter. It blocks all input except mouse movement, a few critical keyboard keys, and the Continue and Menu buttons. So you should always allow a continue button when blocking input. You shouldn't block input for a sticky subtitle! If the speech file is not available, a placeholder time will be calculated for the message using the number of words and the message will be displayed for that length of time.<BR/> Actors: ACTOR.GenericAlly, ACTOR.GenericAxis, ACTOR.Keller, ACTOR.McKay, ACTOR.Conti, ACTOR.Franks, ACTOR.Peoples, ACTOR.Coogi, etc...

 
Void  Actor_PlaySpeechWithoutPortrait( ActorTable actor, Integer locID[, Boolean continueButton, Boolean stickySubtitle, Boolean blockInput] )
 	
Plays a speech event for a given actor WITHOUT a portrait or subtitle. See Actor_PlaySpeech for more details 

 
Void  Actor_SetFromSGroup( ActorTable actor, SGroupID sgroup )
 	
Tie an entire sgroup to an actor, so audio comes from a squad member 

 
Void  Actor_SetFromSquad( ActorTable actor, SquadID squad )
 	
Tie a single squad to an actor, so audio comes from a squad member 

 
 

 

Proximity
Functions

Boolean  Prox_AreEntitiesNearMarker( EGroupID egroup, MarkerID/Position/SectorID position, Boolean all[, Real range] )
 	
Returns true if ANY or ALL entities from a group are in range of a given position, marker, or territory sector. 

Markers with proximity type rectangle will use circular proximity check if custom range is supplied<BR/>

 
Boolean  Prox_ArePlayerMembersNearMarker( PlayerID player, MarkerID/Position/SectorID position, Boolean all[, Real range, SBP/Table filterlist, Integer filtertype] )
 	
Returns true if ANY or ALL of a player's members (i.e. individual guys, not squads as a whole) are in range of a given position, marker, or territory sector. DO NOT USE THIS FUNCTION UNLESS YOU ABSOLUTELY HAVE TO!! 

You MUST specify a range if you are using a position rather than a marker.

 
Boolean  Prox_ArePlayersNearMarker( PlayerID player, MarkerID/Position/SectorID position, Boolean all[, Real range, SBP/Table filterlist, Integer filtertype] )
 	
Returns true if ANY or ALL of a player's squads are in range of a given position, marker, or territory sector. THIS FUNCTION IS VERY SLOW. DO NOT USE THIS UNLESS ABSOLUTELY NECESSARY. 

Markers with proximity type rectangle will use circular proximity check if custom range is supplied<BR/>

 
Boolean  Prox_AreSquadMembersNearMarker( SGroupID sgroup, MarkerID/Position/SectorID position, Boolean all[, Real range] )
 	
Returns true if ANY or ALL squad members (i.e. individual guys, not squads as a whole) from a group are in range of a given position, marker, or territory sector. DO NOT USE THIS FUNCTION UNLESS YOU ABSOLUTELY HAVE TO!! 

Markers with proximity type rectangle will use circular proximity check if custom range is supplied<BR/>

 
Boolean  Prox_AreSquadsNearMarker( SGroupID sgroup, MarkerID/Position/SectorID position, Boolean all[, Real range] )
 	
Returns true if ANY or ALL squads from a group are in range of a given position, marker, or territory sector 

Markers with proximity type rectangle will use circular proximity check if custom range is supplied<BR/>

 
Boolean  Prox_AreTeamsNearMarker( TeamID team, MarkerID/Position/SectorID position, Boolean all[, Real range, SBP/Table filterlist, Integer filtertype] )
 	
Returns true if ANY or ALL of a teams's squads are in range of a given position, marker, or territory sector. THIS FUNCTION IS VERY SLOW. DO NOT USE THIS UNLESS ABSOLUTELY NECESSARY. 

Markers with proximity type rectangle will use circular proximity check if custom range is supplied<BR/>

 
Real  Prox_EGroupEGroup( EGroupID egroup1, EGroupID egroup2, ProxType checktype )
 	
Returns the distance between two entity groups. use checktype PROX_SHORTEST, PROX_LONGEST, or PROX_CENTER. 

If check is PROX_SHORTEST this will return the shortest distance between the two groups.<BR/> If check is PROX_LONGEST this will return the longest distance between the two groups.<BR/> If check is PROX_CENTER this will return the distance between the two groups centers.<BR/>

 
Real  Prox_EGroupSGroup( EGroupID egroup1, SGroupID sgroup2, ProxType checktype )
 	
Returns the distance between an entity group and a squad group. use checktype PROX_SHORTEST, PROX_LONGEST, or PROX_CENTER. 

If check is PROX_SHORTEST this will return the shortest distance between the two groups.<BR/> If check is PROX_LONGEST this will return the longest distance between the two groups.<BR/> If check is PROX_CENTER this will return the distance between the two groups centers.<BR/>

 
Boolean  Prox_EntitiesInProximityOfEntities( EGroupID egroup1, EGroupID egroup2, Real proximity, Boolean all )
 	
Checks if ALL or ANY entities are in proximity of a given entity group. 

Set "all" to true to check that ALL entities are in proximity, or set "all" to false to check for ANY.

 
Position  Prox_GetRandomPosition( Object item, Integer radius, Integer minimum )
 	
Takes something (Entity, Squad, SGroup, EGroup, Position) in, then returns a random position 

Minimum is ignored if it is greater than the radius

 
Real  Prox_MarkerEGroup( MarkerID marker, EGroupID egroup, ProxType checktype )
 	
Returns the distance between a marker and an entity group. use checktype PROX_SHORTEST, PROX_LONGEST, or PROX_CENTER. 

If check is PROX_SHORTEST this will return the shortest distance between the two groups.<BR/> If check is PROX_LONGEST this will return the longest distance between the two groups.<BR/> If check is PROX_CENTER this will return the distance between the two groups centers.<BR/>

 
Real  Prox_MarkerSGroup( MarkerID marker, SGroupID sgroup, ProxType checktype )
 	
Returns the distance between a marker and a squad group. use checktype PROX_SHORTEST, PROX_LONGEST, or PROX_CENTER. 

If check is PROX_SHORTEST this will return the shortest distance between the two groups.<BR/> If check is PROX_LONGEST this will return the longest distance between the two groups.<BR/> If check is PROX_CENTER this will return the distance between the two groups centers.<BR/>

 
Boolean  Prox_PlayerEntitiesInProximityOfEntities( PlayerID playerid, EGroupID egroup, Real proximity, Boolean all, EntityID exclude )
 	
Checks if ALL or ANY players squads are in proximity of a given entity group. 

Set "all" to true to check that ALL entities are in proximity, or set "all" to false to check for ANY.

 
Boolean  Prox_PlayerEntitiesInProximityOfPlayerSquads( PlayerID playerentities, PlayerID playersquads, Real proximity, Boolean all )
 	
Checks if ALL or ANY players entities are in proximity of a given squad group. 

Set "all" to true to check that ALL entities are in proximity, or set "all" to false to check for ANY.

 
Boolean  Prox_PlayerEntitiesInProximityOfSquads( PlayerID playerid, SGroupID sgroup, Real proximity, Boolean all )
 	
Checks if ALL or ANY players entities are in proximity of a given squad group. 

Set "all" to true to check that ALL entities are in proximity, or set "all" to false to check for ANY.

 
Boolean  Prox_PlayerSquadsInProximityOfEntities( PlayerID playerid, EGroupID egroup, Real proximity, Boolean all, SBP/Table filterlist, Int filtertype )
 	
Checks if ALL or ANY players squads are in proximity of a given entity group. 

Set "all" to true to check that ALL squads are in proximity, or set "all" to false to check for ANY.

 
Boolean  Prox_PlayerSquadsInProximityOfPlayerEntities( PlayerID playersquads, PlayerID playerentities, Real proximity, Boolean all )
 	
Checks if ALL or ANY players squads are in proximity of a given players entities. 

Set "all" to true to check that ALL squads are in proximity, or set "all" to false to check for ANY.

 
Boolean  Prox_PlayerSquadsInProximityOfPlayerSquads( PlayerID playerid1, PlayerID playerid2, Real proximity, Boolean all )
 	
Checks if ALL or ANY players squads are in proximity of a given players squads. 

Set "all" to true to check that ALL squads are in proximity, or set "all" to false to check for ANY.

 
Boolean  Prox_PlayerSquadsInProximityOfSquads( PlayerID playerid, SGroupID sgroup, Real proximity, Boolean all, SquadID exclude, SBP/Table filterlist, Int filtertype )
 	
Checks if ALL or ANY players squads are in proximity of a given squad group. 

Set "all" to true to check that ALL squads are in proximity, or set "all" to false to check for ANY.

 
Real  Prox_SGroupSGroup( SGroupID sgroup1, SGroupID sgroup2, ProxType checktype )
 	
Returns the distance between two squad groups. use checktype PROX_SHORTEST, PROX_LONGEST, or PROX_CENTER. 

If check is PROX_SHORTEST this will return the shortest distance between the two groups.<BR/> If check is PROX_LONGEST this will return the longest distance between the two groups.<BR/> If check is PROX_CENTER this will return the distance between the two groups centers.<BR/>

 
Boolean  Prox_SquadsInProximityOfEntities( SGroupID sgroup, EGroupID egroup, Real proximity, Boolean all )
 	
Checks if ALL or ANY squads are in proximity of a given entity group. 

Set "all" to true to check that ALL squads are in proximity, or set "all" to false to check for ANY.

 
Boolean  Prox_SquadsInProximityOfSquads( SGroupID sgroup1, SGroupID sgroup2, Real proximity, Boolean all )
 	
Checks if ALL or ANY squads are in proximity of a given squad group. 

Set "all" to true to check that ALL squads are in proximity, or set "all" to false to check for ANY.

 
 

 

RuleSystem
Functions

Void  Rule_Add( LuaFunction rule[, Integer priority] )
 	
Add a rule to be executed every frame. Priority can be from 0 to 1000, with 0 being the lowest. Priority is used in conjunction with Rule_RemoveAll so that rules with high priority do not get removed. 

 
Void  Rule_AddDelayedInterval( LuaFunction rule, Real delay, Real interval[, Integer priority] )
 	
Add a rule to be executed at every 'interval' seconds, after an initial delay. Priority can be from 0 to 1000, with 0 being the lowest. Priority is used in conjunction with Rule_RemoveAll so that rules with high priority do not get removed. 

 
Void  Rule_AddDelayedIntervalEx( LuaFunction rule, Real delay, Real interval, Integer calls[, Integer priority, Integer calls] )
 	
Add a rule to be executed 'calls' times, at every 'interval' seconds, after an initial delay. Priority can be from 0 to 1000, with 0 being the lowest. Priority is used in conjunction with Rule_RemoveAll so that rules with high priority do not get removed. 

 
Void  Rule_AddEGroupEvent( LuaFunction rule, EGroupID egroup, Integer eventtype )
 	
Add a rule to be executed when the event of 'eventType' has happened on entities in the 'egroup' 

Event types are: GE_EntityKilled

 
Void  Rule_AddEntityEvent( LuaFunction rule, EntityID entity, Integer eventtype )
 	
Add a rule to be executed when the event of 'eventType' has happened on the 'entity' 

Event types are: GE_EntityKilled

 
Void  Rule_AddGlobalEvent( LuaFunction rule, Integer eventtype )
 	
Add a rule to be executed when the event of 'eventType' has happened, regardless of source 

Event types are: GE_PlayerBeingAttacked

 
Void  Rule_AddInterval( LuaFunction rule, Real interval[, Integer priority] )
 	
Add a rule to be executed at every 'interval' seconds. Priority can be from 0 to 1000, with 0 being the lowest. Priority is used in conjunction with Rule_RemoveAll so that rules with high priority do not get removed. 

 
Void  Rule_AddIntervalEx( LuaFunction rule, Real interval, Integer calls[, Integer priority] )
 	
Add a rule to be executed 'calls' times, at every 'interval' seconds. Priority can be from 0 to 1000, with 0 being the lowest. Priority is used in conjunction with Rule_RemoveAll so that rules with high priority do not get removed. 

 
Void  Rule_AddOneShot( LuaFunction rule, Real delay[, Integer priority] )
 	
Add a rule to be executed once, after 'delay' seconds. Priority can be from 0 to 1000, with 0 being the lowest. Priority is used in conjunction with Rule_RemoveAll so that rules with high priority do not get removed. 

 
Void  Rule_AddPlayerEvent( LuaFunction rule, PlayerID player, Integer eventtype )
 	
Add a rule to be executed when the event of 'eventType' has happened on the 'player' 

Event types are: GE_PlayerBeingAttacked

 
Void  Rule_AddSGroupEvent( LuaFunction rule, SGroupID sgroup, Integer eventtype )
 	
Add a rule to be executed when the event of 'eventType' has happened on squads in the 'sgroup' 

Event types are: GE_SquadKilled, GE_SquadPinned, GE_SquadCommandIssued, GE_AbilityExecuted

 
Void  Rule_AddSquadEvent( LuaFunction rule, SquadID squad, Integer eventtype )
 	
Add a rule to be executed when the event of 'eventType' has happened on the 'squad' 

Event types are: GE_SquadKilled, GE_SquadPinned, GE_SquadCommandIssued, GE_AbilityExecuted

 
Void  Rule_ChangeInterval( LuaFunction rule, Real interval )
 	
Change 'interval' seconds of an existing rule 

 
Boolean  Rule_Exists( LuaFunction rule )
 	
Test if a rule is currently active 

 
Void  Rule_Remove( LuaFunction rule )
 	
Remove a currently active rule (this does not remove any event rules) 

 
Void  Rule_RemoveAll( [Integer max_priority] )
 	
Kills all rules below a certain priority. The default is to remove ALL rules. 

 
Void  Rule_RemoveEGroupEvent( LuaFunction rule, EGroupID egroup )
 	
Remove an active event rule for entities in the 'egroup' 

 
Void  Rule_RemoveEntityEvent( LuaFunction rule, EntityID entity )
 	
Remove an active event rule for the 'entity' 

 
Void  Rule_RemoveGlobalEvent( LuaFunction rule )
 	
Remove an active event rule that's been applied 'globally' 

 
Void  Rule_RemoveIfExist( LuaFunction rule )
 	
Remove a currently active rule if it exists(this does not remove any event rules) 

 
Void  Rule_RemoveMe( )
 	
Remove a currently executing rule (only works inside a rule function) 

 
Void  Rule_RemovePlayerEvent( LuaFunction rule, PlayerID player )
 	
Remove an active event rule for the 'player' 

 
Void  Rule_RemoveSGroupEvent( LuaFunction rule, SGroupID sgroup )
 	
Remove an active event rule for squads in the 'sgroup' 

 
Void  Rule_RemoveSquadEvent( LuaFunction rule, SquadID squad )
 	
Remove an active event rule for the 'squad' 

 
 

 

Setup
Functions

PlayerID  Setup_Player( Integer playerIndex, LocString playerName, String playerRace, Integer team )
 	
Initializes the all of the players settings in one function and returns the playerID. 

In most cases you will call this function from OnGameSetup and store the returned playerId in a global variable. The player index should be in the range [1 , (numPlayers)].<BR/><BR/> Valid player races: "Allied Airborne Company", "Allied Assault Company", "Allied Rifle Company", "Allied Tank Company", "Axis Armored Company","Axis Heavy Tank Company", "Axis Infantry Company","Axis Pioneer Company"<BR/><BR/> Example:<BR/> function OnGameSetup( )<BR/> <TAB/>g_player1 = Setup_Player(0, "PlayerDisplayName", "Allied Assault Company", 1)<BR/> <TAB/>-- g_player2 and g_player3 will be on the same team (allies)<BR/> <TAB/>g_player2 = Setup_Player(1, "$20000", "Axis Infantry Company", 2)<BR/> <TAB/>g_player3 = Setup_Player(2, "$20001", "Axis Infantry Company", 2)<BR/> --? The team ID starts from one!! end

 
 

 

SGroup
Functions

Void  Cmd_StopSquadsExcept( SGroupID sgroup1[, Boolean stopCapture, Boolean stopBuild] )
 	
Pass in a group to command to 'stop'. Pass in booleans for capturing and building 

 
Void  Misc_IsEGroupOnScreen( EGroupID group, Real percent, Boolean all )
 	
Test whether ANY or ALL of an EGroup is on screen currently (not strict)  

 
Void  Misc_IsSGroupOnScreen( SGroupID group, Real percent, Boolean all )
 	
Test whether ANY or ALL of an SGroup is on screen currently (not strict)  

 
Void  Rule_AddEGroupEvent( LuaFunction fule, EGroup egroup, Integer eventtype )
 	
Add a rule to be executed when the event of 'eventType' has happened on the 'EGroup' Event types are: GE_EntityKilled 

 
void  SGroup_Add( SGroup* group, Squad* squadron )
 	
Adds an squadron to the end of a group if the group doesnt already have it. 

 
Void  SGroup_AddAbility( SGroupID sgroup, AbilityBlueprint ability )
 	
Adds an ability to all squads in an sgroup. 

 
void  SGroup_AddGroup( SGroup* group, SGroup* grouptoadd )
 	
Same as EGroup_AddGroup. Note: You cannot mix squad groups and entity groups. 

 
Void  SGroup_AddGroups( SGroupID sgroup, Table groupList )
 	
Add a list of multiple sgroups into an existing group. 

 
Void  SGroup_AddLeaders( SGroupID sgroup )
 	
Adds a leader to all squads in a group that can take a leader. 

This function will bypass all cost and queue prereqs

 
Void  SGroup_AddSlotItemToDropOnDeath( SGroupID groupid, Int itemid, Float drop_chance, Bool exclusive )
 	
Add to the list of slot items to drop when any one of the squads is wiped out 

SGroup_AddSlotItemToDropOnDeath( squadid, item, false )

 
Void  SGroup_CanCastAbilityOnEntity( SGroupID caster, AbilityBlueprint ability, EntityID target_entity, Boolean all )
 	
Test whether ANY or ALL of a group can be ordered to do this ability on the target squad 

 
Void  SGroup_CanCastAbilityOnPosition( SGroupID caster, AbilityBlueprint ability, Position position, Boolean all )
 	
Test whether ANY or ALL of a group can be ordered to do this ability on the target position 

 
Void  SGroup_CanCastAbilityOnSquad( SGroupID caster, AbilityBlueprint ability, SquadID target_squad, Boolean all )
 	
Test whether ANY or ALL of a group can be ordered to do this ability on the target entity 

 
Boolean  SGroup_CanInstantReinforceNow( SGroupID group, Boolean all )
 	
Return true if ANY or ALL of a group can reinforce now 

 
Boolean  SGroup_CanSeeSGroup( SGroupID sgroup, SGroupID targetsgroup, Boolean all )
 	
Returns true if ALL or ANY squads in a group can see ALL or ANY squads in a target sgroup. 

 
void  SGroup_Clear( SGroup* sgroup )
 	
Removes all entities from a group. 

 
void  SGroup_ClearPostureSuggestion( SGroup* sgroup )
 	
Clears any previous posture suggestions made to a squad 

 
bool  SGroup_Compare( SGroup* group1, SGroup* group2 )
 	
Returns true if the contents of the two groups are equal. Order of the entities does not matter. 

 
Void  SGroup_CompleteEntityUpgrade( SGroupID sgroup, UpgradeID upgrade )
 	
Applies an upgrade to all squad entities in an sgroup. 

 
Boolean  SGroup_ContainsBlueprints( SGroupID sgroup, BP/Table blueprints, Boolean all )
 	
Check if a group contains ALL or ANY of the blueprints. 

 
bool  SGroup_ContainsSGroup( SGroup* group1, SGroup* group2, bool all )
 	
Returns true if SGroup1 contains ANY or ALL of SGroup2 

 
bool  SGroup_ContainsSquad( SGroup* group, uint32_t SquadID )
 	
Returns true if SGroup contains a particular SquadID 

 
int  SGroup_Count( SGroup* sgroup )
 	
Returns the total number of spawned and despawned squads in a group. 

NOTE: SGroup_Count does not count the individual soldiers in an SGroup. For that, use SGroup_TotalMembersCount

 
int  SGroup_CountDeSpawned( SGroup* sgroup )
 	
Returns the number of despawned squads in a group. 

 
int  SGroup_CountSpawned( SGroup* sgroup )
 	
Returns the number of spawned squads in a group. 

 
SGroup*  SGroup_Create( const char* name )
 	
Returns a new squadron group with the given name.  

Squad groups are used for all units and vehicles. You can issue orders such as move and attack to an entire squad group. If you want a group for buildings or objects such as trees, use an EntityGroupObs instead.<BR/> Note that you are allowed to have unamed squadgroups or squadgroups with the samename. Be careful not to create duplicates of your squad group when you dont intend to. To be safe, you can check if the SquadGroupObs you want to create exists using SGroup_Exists( )

 
SGroupID  SGroup_CreateIfNotFound( String name )
 	
Find a squad group from name. Creates a new one with given name if it doesnt exist. 

 
Void  SGroup_CreateKickerMessage( SGroupID group, PlayerID player, LocString textid )
 	
Create and display kicker message on the each squad in the sgroup to the player 

 
Void  SGroup_DeSpawn( SGroupID groupid )
 	
Despawn all spawned squads in a group. 

 
void  SGroup_Destroy( SGroup* egroup )
 	
Manually destroy a group that you dont need anymore. 

 
Void  SGroup_DestroyAllInMarker( SGroupID sgroup, MarkerID marker )
 	
Destroys all items in a group that are in proximity to a given marker. 

 
Void  SGroup_DestroyAllSquads( SGroupID sgroup )
 	
Destroys all spawned and despawned squads in a group. 

Be careful not to confuse this with SGroup_Destroy which destroys the group and NOT the squads it contains. This function will destroy spawned and despawned items in a group

 
Void  SGroup_DisableCombatPlans( SGroupID groupID )
 	
Disables all current combat plans for the squads in the sgroup 

 
Void  SGroup_Duplicate( SGroupID sgroup1, SGroupID sgroup2 )
 	
Duplicates an SGroup 

Creates a copy of sgroup1 in sgroup2. The function will clear sgroup2 beforehand if necessary.

 
Void  SGroup_EnableAttention( SGroupID sgroup, Boolean attentive )
 	
Sets whether an entity pays attention to its surroundings 

 
Void  SGroup_EnableMinimapIndicator( SGroupID group, Boolean enable )
 	
Enable or disable minimap indicator on all squads in the sgroup 

 
Void  SGroup_EnableSurprise( SGroupID groupid, Boolean enable )
 	
Enables or disables the surprise feature for an sgroup 

 
Void  SGroup_EnableUIDecorator( SGroupID group, Boolean enable )
 	
Enable or disable decorators on all squads in the sgroup  

 
bool  SGroup_Exists( const char* name )
 	
Returns true if the squad group with the given name exists 

 
Void  SGroup_FaceEachOther( SGroupID sgroup1, SGroupID sgroup2 )
 	
Makes two SGroups face each other 

 
Void  SGroup_FaceMarker( SGroupID sgroup, MarkerID marker )
 	
Makes a SGroup face a marker. 

 
Void  SGroup_Filter( SGroupID sgroup, ID/Table blueprint, Integer!filtertype [, SGroupID splitSGroup] )
 	
Filters an SGroup by blueprint. 

Blueprints can be provided by name or by ID, and in a table if you want to filter on more than one type. Setting filtertype to FILTER_KEEP results in the group only containing squads of the types listed in the blueprint table. Setting filtertype to FILTER_REMOVE will strip those same squads out and leave those that aren't of the types listed. Setting splitSGroup will move any squads being KEEP or REMOVE to it. This SGroup will NOT be cleared beforehand.

 
Void  SGroup_FilterCount( SGroupID sgroup1, Int groupSize )
 	
Pass in a group and it will filter it down to the indicated number 

 
Void  SGroup_FilterThreat( SGroupID sgroup, LuaTable tableSBPs, [Boolean bEmpty] )
 	
Searches an SGroup and finds the first threat within the table (searching first to last) and removes all other SBPs. 

Optional parameter bEmpty can be set to true, will clear the SGroup if none of the SBPS in the table are found.

 
bool  SGroup_ForEach( SGroup* sgroup, LuaBinding::StackVarFunction f )
 	
Call a lua function for each item in a group. Function will recieve (groupid, itemindex, itemid) and should return true to break or false to continue. 

function Rule_Test( )<BR/> <TAB/>local DespawnSquad = function( sgroupid, itemindex, squadID )<BR/> <TAB/><TAB/>Squad_Despawn( squadID )<BR/> <TAB/>end<BR/><BR/> <TAB/>SGroup_ForEach( SGroup_FromName("sg_Squads"), DespawnSquad )<BR/> end<BR/><BR/> This functions iterates over spawned squads only.

 
bool  SGroup_ForEachAllOrAny( SGroup* sgroup, bool all, LuaBinding::StackVarFunction f )
 	
Call a lua function for each item in a group. Function will receive (groupid, itemindex, itemid) and should return a bool. 

Only use this to TEST conditions on squads. DO NOT use this to perform operations on all squads, since it may not call your function on all squads (due to short circuit evaluation). This is used for checking if ALL or ANY items in a group match a given predicate. (eg. Are all items in a group chaos marines)<BR/> This functions iterates over spawned squads only.

 
bool  SGroup_ForEachAllOrAnyEx( SGroup* sgroup, bool all, LuaBinding::StackVarFunction f, bool spawned, bool despawned )
 	
Same as SGroup_ForEachAllOrAny except you have a choice to iterate over spawned squads, despawned squads, or both. 

 
bool  SGroup_ForEachEx( SGroup* sgroup, LuaBinding::StackVarFunction f, bool spawned, bool despawned )
 	
Same as SGroup_ForEach except you have a choice to iterate over spawned squads, despawned squads, or both. 

 
SGroup*  SGroup_FromName( const char* name )
 	
Find an squadron group with a given name. 

 
Real  SGroup_GetAvgHealth( SGroupID sgroup )
 	
Returns the average health of all units in a squad group. 

It now uses the same health measure that's used by the UI, so it does take into account fallen members of a squad

 
Real  SGroup_GetAvgLoadout( SGroup sgroup )
 	
Returns the average loadout of all squads in a group as a percent [0.0, 1.0]. 

Example: A group of squads with loadouts of 4/8 and 1/1 would return 0.75

 
Squad*  SGroup_GetDeSpawnedSquadAt( SGroup* group, unsigned int index )
 	
Returns the despawned squad at a certain position in the group. 

This is a one-based index (use index 1 to get the first squad in the group.) It is an error if index > SGroup_GetDeSpawnedCount().

 
EntityID  SGroup_GetGarrisonedBuildingEntity( SGroupID groupid )
 	
Get the entity id of the building that any squad of the sgroup is garrisoned in 

 
Void  SGroup_GetHoldEGroup( SGroupID sgroup, EGroup EGroupHold )
 	
Gets all the entities that an SGroup may occupy and adds them to the EGroupHold 

 
Void  SGroup_GetHoldSGroup( SGroupID sgroup, SGroup SGroupHold )
 	
Gets all the squads that an SGroup may occupy and adds them to the SGroupHold 

 
Boolean  SGroup_GetInvulnerable( SGroupID sgroup, Boolean all )
 	
Check invulnerablity state for ALL or ANY squads in a squad group. 

Set all param to true to check for ALL or set to false to check for ANY.

 
Void  SGroup_GetLastAttacker( SGroup SGroupVictim, SGroup SGroupAttacker[, Real seconds] )
 	
Gets the last attacker(s) for all the squads in an SGroup Gets the last attacker for all the squads in an SGroup and stores that in SGroupAttacker 

 
SquadID  SGroup_GetLoadedVehicleSquad( SGroupID groupid )
 	
Get the squad id of the vehicle squad that any squad of the sgroup is loaded in 

 
const char*  SGroup_GetName( SGroup* sgroup )
 	
Returns the name of a given squad group. 

 
Int  SGroup_GetNumSlotItem( SGroupID group, Int itemID )
 	
Get the number of slot items with the same ID that the squads in the sgroup own 

 
Position  SGroup_GetOffsetPosition( SGroupID sgroup, Integer offset, Real value )
 	
Returns a position (a certain distance away) relative to a squad's current position/orientation. see LuaConsts.scar for explanation of 'offset' parameter 

 
ScarPosition  SGroup_GetPosition( SGroup* group )
 	
Returns the center position of a squad group. 

Despawned squads are ignored.

 
SquadID  SGroup_GetRandomSpawnedSquad( SGroup sgroupid )
 	
Get a random spawned squad from sgroup 

 
Table  SGroup_GetSequence( String name )
 	
Builds a table of SGroupIDs that are named in a sequence. i.e. a name of "sg_killer" will find groups "sg_killer1", "sg_killer2" and so on, up until it looks for a group that isn't there. 

 
Squad*  SGroup_GetSpawnedSquadAt( SGroup* group, unsigned int index )
 	
Returns the spawned squad at a certain position in the group. 

This is a one-based index (use index 1 to get the first squad in the group.) It is an error if index > SGroup_GetSpawnedCount().

 
Real  SGroup_GetSpread( SGroupID sgroup )
 	
Returns the distance from the centre of the group of the unit that furthest out.  

 
Void  SGroup_GetSquadsHeld( SGroupID sgroup, SGroupID sgroupRecipient )
 	
Returns an sgroup containing all squads held by any squad in an sgroup 

 
Float  SGroup_GetSuppression( SGroupID groupid )
 	
Get the suppression level for the first squad in the sgroup 

 
Float  SGroup_GetVeterancyExperience( SGroupID groupid )
 	
Get the veterancy experience value for the first squad in the sgroup 

 
Int  SGroup_GetVeterancyRank( SGroupID groupid )
 	
Get the veterancy rank for the first squad in the sgroup 

 
Boolean  SGroup_HasCritical( SGroupID group, CriticalID critical, Boolean all )
 	
Returns true if ANY or ALL of the squads in the SGroup have the specified critical 

 
Boolean  SGroup_HasLeader( SGroupID sgroup, Boolean all )
 	
Check if ALL or ANY squads in a sgroup have a leader 

Set all param to true to check for ALL or set to false to check for ANY.

 
Boolean  SGroup_HasSquadBlueprint( SGroupID sgroup, BP blueprint, Boolean all )
 	
Check if ALL or ANY of the squads in a group have a specific blueprint. 

 
Boolean  SGroup_HasTeamWeapon( SGroupID sgroup, Boolean all )
 	
Returns true if ANY or ALL of the squads in an SGroup are carrying some kind of team weapon 

 
Boolean  SGroup_HasUpgrade( SGroupID sgroup, UpgradeID upgrade, Boolean all )
 	
Returns whether ANY or ALL squads in an SGroup have the specified upgrade 

 
Void  SGroup_Hide( SGroupID sgroup, Bool hide )
 	
Hide or show all entities in all squads in an SGroup 

Bool should be true to hide, false to show

 
Void  SGroup_IncreaseVeterancyExperience( SGroupID groupid, Float experience[, Boolean silent, Boolean applyModifiers] )
 	
Increase squad veterancy experience for all squads in the sgroup. Can do silent promotion (no sound/UI). Can skip modifiers, giving you direct control of experience gained. 

 
Void  SGroup_IncreaseVeterancyRank( SGroupID groupid[, Integer numranks, Boolean silent] )
 	
Increase squad veterancy rank for all squads in the sgroup. By default, increases rank by 1. Can do silent promotion (no sound/UI. ex: mass rank insrease at mission start) 

 
void  SGroup_Intersection( SGroup* group, SGroup* grouptointersect )
 	
Same as EGroup_Intersection. Note: You cannot mix squad groups and entity groups. 

Only squads that are in both groups will be added to 'group'.<BR/> The contents of 'grouptointersect' will not be changed.<BR/> Example: group = (1,2,3,4,5,6) grouptointersect = (2,4,6,8,10) --> group will now equal (2,4,6)

 
Boolean  SGroup_IsAlive( SGroupID sgroup )
 	
Returns true if a named squad group is not empty and its average health is > 0.0 

 
Boolean  SGroup_IsAttackMoving( SGroupID sgroup, Boolean all )
 	
Returns true if ANY or ALL squads in an SGroup are attack moving. 

 
Boolean  SGroup_IsCamouflaged( SGroupID sgroup, Boolean all )
 	
Returns true if ANY or ALL of the squads in an SGroup are camouflaged 

 
Boolean  SGroup_IsCapturing( SGroupID sgroup, Boolean ALL )
 	
Checks if ANY or ALL squads in an SGroup are capturing 

 
Boolean  SGroup_IsConstructingBuilding( SGroup sgroup, Boolean all )
 	
Returns true if ALL or ANY squads in a group are currently constructing a building. 

Set all to true to check for ALL or set to false to check for ANY

 
Boolean  SGroup_IsDoingAbility( SGroupID sgroupid, AbilityID ability, Boolean all )
 	
Returns if ANY or ALL members of an SGroup are doing an ability 

 
Boolean  SGroup_IsDoingAttack( SGroupID sgroup, Boolean all, Float time )
 	
Returns true if ALL or ANY squads are attacking within the time. 

 
Boolean  SGroup_IsDugIn( SGroupID group, Boolean all )
 	
Returns true if ANY or ALL of the squads in the SGroup is dug in (or in the process of digging in) 

 
Boolean  SGroup_IsEmpty( SGroupID sgroup )
 	
Returns true if a named squad group is empty 

 
Boolean  SGroup_IsFemale( SGroupID sgroup, Boolean all )
 	
Returns true if ANY or ALL squads are female 

 
Void  SGroup_IsHoldingAny( SGroupID sgroup )
 	
Returns whether any entity in an SGroup has a hold on anything 

 
Boolean  SGroup_IsIdle( SGroupID sgroup, Boolean ALL )
 	
Checks if ANY or ALL squads in an SGroup are idle 

 
Real/Boolean  SGroup_IsInCover( SGroupID sgroup[, Boolean all] )
 	
Returns the percentage of the SGroup members that are in cover. Alternatively, specify ANY or ALL as a second parameter to return true/false. 

 
Boolean  SGroup_IsInfiltrated( SGroupID sgroup, Boolean all )
 	
Returns true if ALL or ANY squads in a group are infiltrated 

 
Boolean  SGroup_IsInHoldEntity( SGroupID sgroup, Boolean ALL )
 	
Checks if ANY or ALL squads in an SGroup are garrisoned in an entity (building)  

 
Boolean  SGroup_IsInHoldSquad( SGroupID sgroup, Boolean ALL )
 	
Checks if ANY or ALL squads in an SGroup are garrisoned in a squad (transport vehicle)  

 
Boolean  SGroup_IsMoving( SGroupID sgroup, Boolean all )
 	
Returns true if ANY or ALL squads in an SGroup are moving. 

 
Bool  SGroup_IsOnScreen( PlayerID player, SGroupID group, Bool all[, Float percent] )
 	
Returns true if ANY or ALL (use those keywords) of the squads in the group are present onscreen. You can pass in a percentage of the screen to check, so 0.8 would be a centered rectangle occupying 80% of the screen. 

 
Boolean  SGroup_IsPinned( SGroupID group, Boolean all )
 	
Returns true if ANY or ALL of a group is pinned 

 
Boolean  SGroup_IsReinforcing( SGroupID sgroup, Boolean all )
 	
Returns true if ALL or ANY squads in a group are currently calling for reinforcments. 

Set all to true to check for ALL or set to false to check for ANY

 
Boolean  SGroup_IsRetreating( SGroupID sgroup, Boolean all )
 	
Returns true if ANY or ALL of the squads in an SGroup are currently retreating 

 
Boolean  SGroup_IsSettingDemolitions( SGroupID sgroup, Boolean all )
 	
Returns true if ANY or ALL squads are setting demolitions 

 
Boolean  SGroup_IsSuppressed( SGroupID group, Boolean all )
 	
Returns true is ANY or ALL of a group is suppressed 

 
Boolean  SGroup_IsUnderAttack( SGroupID sgroup, Boolean all, Float time )
 	
Returns true if ALL or ANY squads are under attack within the time. 

 
Bool  SGroup_IsUnderAttackByPlayer( SGroupID group, PlayerID attackerplayer, Float duration )
 	
Check if the squads are attacked by the player 

 
Boolean  SGroup_IsUnderAttackFromDirection( SGroupID sgroup, Boolean all, Integer offset, Float time )
 	
Returns true if ALL or ANY squads are under attack from a direction within the time. see LuaConsts.scar for types of directions. you can pass in a table of directions 

 
Boolean  SGroup_IsUpgrading( SGroupID sgroup, UpgradeBlueprint blueprint, Boolean all )
 	
Returns true if ALL or ANY squads in a group are currently upgrading. You can pass in nil for upgradeid if it doesn't matter what is being upgraded. 

Set all to true to check for ALL or set to false to check for ANY

 
Boolean  SGroup_IsUsingAbility( SGroupID sgroup, Boolean ALL )
 	
Checks if ANY or ALL squads in an SGroup are using an ability 

Does not check WHAT ability a squad is using.

 
Void  SGroup_Kill( SGroupID sgroup )
 	
Kills all squads in an SGroup. This kills them 'naturally', as opposed to SGroup_DestroyAllSquads() which makes them blink out of existance. 

 
void  SGroup_Remove( SGroup* group, Squad* squadron )
 	
Removes an squadron from a group. 

 
Void  SGroup_RemoveGroup( SGroupID group, SGroupID grouptoremove )
 	
Remove from the first SGroup all squads contained in the second SGroup. SGroup2 remains untouched. 

 
Void  SGroup_RemoveUpgrade( SGroupID sgroup, UpgradeBlueprint/Table upgrade )
 	
Removes upgrade(s) from an sgroup 

 
Void  SGroup_ReSpawn( SGroupID groupid )
 	
Respawn all despawned squads in a group. 

 
Void  SGroup_RestoreCombatPlans( SGroupID sgroupID )
 	
Restore all current combat plans for the squads in the sgroup 

 
Void  SGroup_RewardActionPoints( SGroupID sgroup, Float actionpoint )
 	
Give action points to the squad 

 
Void  SGroup_SetAnimatorState( SGroupID sgroupid, String stateMachineName, String stateName )
 	
Set animation state of a state machine for an SGroup. Please only use this for simple animations 

 
Void  SGroup_SetAutoTargetting( SGroupID group, String hardpoint, Bool enable )
 	
Sets whether a weapon to auto-target things or not 

 
Real  SGroup_SetAvgHealth( SGroupID sgroup, Real healthpercent )
 	
Sets the health of each squad in a squad group to a given percent [0.0, 1.0]. 

 
Real  SGroup_SetAvgMorale( SGroup sgroup, Real moralepercent )
 	
Sets the moral of each squad in a squad group to a given percent [0.0, 1.0]. 

 
Void  SGroup_SetCrushable( SGroupID sgroup, Boolean crushable )
 	
Overrides crushable behavior for an sgroup 

 
Void  SGroup_SetInvulnerable( SGroupID sgroup, Boolean/Real enabled[, Float reset_time] )
 	
Enable/Disable invulnerablity for an entire SGroup. Use true and false for simple on/off, or use a number between 0.0 and 1.0 for more precise control on how much damage a squad can take before it takes no more. 

The optional reset_time is used to automatically remove invulnerability after a set time. If invulnerable, both health and critical damage are disabled.

 
Void  SGroup_SetInvulnerableToCritical( SGroupID sgroup, Boolean/Real enabled )
 	
Enable/Disable invulnerablity to criticals for an entire SGroup. 

 
Void  SGroup_SetMoodMode( SGroupID group, Integer mode )
 	
Set soldier mood mode. Mode could be MM_Auto, MM_ForceCalm or MM_ForceTense 

 
Void  SGroup_SetMoveType( SGroupID group, MoveTypeBlueprint movetype )
 	
Set the move type for an SGroup - find the move types in the MOVETYPE table in LuaConsts.scar 

 
Void  SGroup_SetPlayerOwner( SGroupID sgroup, PlayerID owner )
 	
Changes the player owner of spawned and despawned squads in an SGroup. 

 
Void  SGroup_SetRecrewable( SGroupID sgroup, Boolean recrewable )
 	
Sets all squads in as sgroup to be recrewable or not when abandoned 

 
Void  SGroup_SetSelectable( SGroup sgroupid, bool selectable )
 	
Set player selectable state of squads in the sgroup 

 
Void  SGroup_SetSharedProductionQueue( SGroupID egroup, Boolean enable )
 	
Enables shared team production on a building (teammates can build using THEIR resources) 

 
Void  SGroup_SetSuppression( SGroupID groupid, Float suppression )
 	
Set the suppression level for all squads in the sgroup 

 
Void  SGroup_SetTeamWeaponCapturable( SGroupID group, Boolean enable )
 	
Set team weapon in the squads to be capturable or not 

 
Void  SGroup_SetVeterancyDisplayVisibility( SGroupID groupid, bool visible )
 	
Sets the visibility of in-game veterancy art for the squads in given SGroup 

 
Void  SGroup_SetWorldOwned( SGroupID sgroup )
 	
Makes an sgroup neutral 

 
SGroupID  SGroup_Single( SGroupID groupID, squadID squad )
 	
Creates a squad group containing a single squad 

Creates an SGroup containing just one squad, creating the group if it doesn't exist and clearing it if it does. It returns the name of the SGroup.

 
Void  SGroup_SnapFaceEachOther( SGroupID sgroup1, SGroupID sgroup2 )
 	
Makes two SGroups face each other at no time 

 
void  SGroup_SuggestPosture( SGroup* sgroup, unsigned posture, float duration )
 	
Suggests a posture to an SGroup, lasting the passed duration 

Posture of 0 is prone, 1 is kneel/crouch, and 2 is standing. Duration is in seconds, negative means indefinate.

 
Integer  SGroup_TotalMembersCount( SGroupID sgroup, Bool dontCountTeamWeapons )
 	
Returns the total count of all members of all the squads in a given SGroup. 

 
Void  SGroup_WarpToMarker( SGroupID sgroup, MarkerID marker )
 	
Warps all members of an SGroup immediately to a marker 

 
Void  SGroup_WarpToPos( SGroupID sgroup, Position pos )
 	
Warps all members of an SGroup immediately to a new position 

 
Sgroup/Egroup Group containing selection  Util_Grab( Boolean subselect )
 	
Grabs the selected squads/entities and returns them in a group. Only works with -dev. 

Tries to return an SGroup first. If it's empty, it will return an EGroup. (Both types can't be selected at the same time)

 
 

 

Squad
Functions

void  SGroup_FacePosition( SGroup* sgroup, ScarPosition pos )
 	
Works like Squad_FacePosition. All Squads will face the same direction, with the squad the closest to the center determining the direction. 

This function works on spawned squads only.

 
void  SGroup_SnapFacePosition( SGroup* sgroup, ScarPosition pos )
 	
Works like SGroup_FacePosition except with no interpolation. All Squads will face the same direction, with the squad the closest to the center determining the direction. 

This function works on spawned squads only.

 
void  Squad_AddAbility( Squad* squad, ScarAbilityPBG ability )
 	
Allows the squad to use this ability 

 
void  Squad_AddSlotItemToDropOnDeath( Squad* squad, ScarSlotItemPBG pbg, float dropChance, bool exclusive )
 	
Add to the list of slot items to drop when this squad is wiped out 

Squad_AddSlotItemToDropOnDeath( squadid, item, false )

 
bool  Squad_CanCaptureStrategicPoint( Squad* squad, Entity* entity )
 	
Returns true if squad can capture stategic point 

 
bool  Squad_CanCaptureTeamWeapon( Squad* pSquad, Entity* pEntity )
 	
True if the squad can capture the entity sync weapon 

 
Void  Squad_CanCastAbilityOnEGroup( SquadID caster, AbilityBlueprint ability, EGroup target_egroup )
 	
Test whether a squad can be ordered to do this ability on any member of the target EGroup 

 
bool  Squad_CanCastAbilityOnEntity( Squad* castingSquad, ScarAbilityPBG abilityPBG, Entity* targetEntity )
 	
Test whether a squad can be ordered to do this ability on the target squad 

 